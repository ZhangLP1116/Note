> 简介
>
> ​		在现实生活中许多法律的、金融的文档真实性是依据是否具有某一个授权人物的手写签名。为了使计算机化的消息系统来代替纸和笔墨文档，必须找到一种方法对文档进行签名，并且签名不可被伪造。
>
> ​		数字签名必须满足下面几个条件：
>
> ​			1、接收方可以验证发送方所声称的身份
>
> ​			2、发送方以后不可能否认该消息
>
> ​			3、接收方不可能自己伪造这样的消息

> 对称密钥签名
>
> ​		使用对称机密算法进行签名，这种方案中需要有一个权威机构，任何发送的消息都需要经过权威机构使用密钥加密后发送给接收方。**这样一来接收方就可以通过权威机构解密来验证发送方的身份是否和消息中的身份一致从而辨别真假。并且发送方无法否认。发送方也无法伪装要为消息都需要通过权威机构签名后才有效。这样依赖就完成了一个数字签名**。（P619-图8-18）
>
> ​		为了避免发送方消息被窃取，发送发可以叫自己的加密密钥交给权威机构，发送消息时用密钥加密，权威机构接收后用密钥解密，任何在使用自己的密钥进行签名，再将带有签名的明文消息发送给接收方。
>
> ​		为了防止重放攻击，每条消息中需要携带时间戳。

> 公开密钥签名
>
> ​		对称密钥签名的问题是如何选择一个权威机构，这个权威机构可以是一个组织，政府等。但是一个权威机构很难使得世界上所有人都信服，这就像让谁来保存你的钱一样。
>
> ​			公开密钥签名解决了这样的问题，在公开密钥签名中不需要权威机构，只需要使用公开密钥算法既可以完成数字签名。这里对公开密钥签名有这样一个要求，算法具有常规的D(E(P))=P属性外，还要有E(D(P))=P的属性，即加密算法和解密算法可以互相交换身份（RSA拥有这样的属性）。
>
> ​			公开密钥签名流程如下：A给B发送消息
>
> ​				1、A用私钥给明文P解密
>
> ​				2、A用B的公钥给D(P)加密，发送给B
>
> ​				3、B接收到消息后，用自己的私钥解密获得D(P)
>
> ​				4、B用A的公钥E(D(P))=P，获得明文
>
> ​			这样一来法官只需要用A的私钥对B出示的明文进行进行E(A)操作就能判断这条消息是否由A发送，要为B不知道A的私钥，只能通过A主动发送才能获得私钥加密的消息。**（发送方不可否认、接收方不能伪装、可以通过公钥解密验证接收方）**

> 消息摘要
>
> ​		上述的两种签名方案中都是对整个明文进行加密从而得到数字签名，是以内容位依据，将认证和保密结合到了一起，实际中往往只需要一种认证一种功能即可，并不需要对明文的加密，而且使用公开加密算法对明文加密太过耗时。
>
> ​		而不对明文进行签名，就要求有一个东西能代表明文——消息摘要（message digest），使用一种单向散列函数接收一个任意长度的明文输出一个固定长度的位串。这个散列函数称为MD，它有下面4个特性。
>
> ​		1、给定P，任意计算MD(P)
>
> ​		2、给定MD(P)，逆推P是不可能的
>
> ​		3、给定P的情况下，不会出现MD(P)=MD(P1)，两个不同的明文不会出现相同的散列值
>
> ​		4、输入的明文任意一位的不同都会导致MD(P)结果不同
>
> ​		为了满足第三条散列结果应该至少为128位，从一个明文得出一个散列值非常容易，使用加密算法对一个128位的散列值进行机密也非常迅速。这使得对散列值进行数字签名得到了广泛应用。
>
> ​		使用消息摘要进行签名的过程：A给B发送消息
>
> ​			1、A对明文进行散列得到散列值H，用自己的私钥对H进行D(H)
>
> ​			2、A将明文和数字签名发送给B
>
> ​			3、B接收到后先对明文进行散列，在使用A的公钥对数字签名进行解密
>
> ​			4、B将自己计算出的散列值和A发送的散列值进行对比，若散列值一致则传输过程中明文没有受到篡改，并且确实由A发送。（这里由于明文不需要保密，所有不需要使用B的公钥对明文进行加密）
>
> ## 		**SHA-1和SHA-2算法**
>
> ​		SHA-1：安全散列算法1（Secure Hash Algorithm 1），它使用非常复杂的方法链弄乱位，以至于它的每个输出位都受到输入位的影响。SHA-1由NSA开发并得到NIST赏识，并被标准化在FIPS 180-1中。它按照512位块大小来处理输入数据。
>
> ​		算法流程：
>
> ​			1、对消息进行填补，先在尾部添加一个1，在用0将消息补充为512的倍数。用64位来表示整个消息的长度（这个长度包含填补的长度），将这64位与消息的最后64位做OR运算。
>
> ​			2、构造5个变量，每个变量32位用于保存散列结果（H0~H5），变量初始值由标准定义
>
> ​			3、将消息以512位单位方块存放（M~0~~M~n-1~）
>
> ​			4、循环处理每个块
>
> ​				1）初始化W~0~~W~79~变量，每个变量32位
>
> ​				2）将512位块存放在W数组前16个单元中
>
> ​				3）对应W数组接下来的每个单元使用：W~i~=S^b^(W~i-3~ XOR W~i-8~ XOR W~i-14~ XOR W~i-16~)(16<=i<=79)，S^b^()表示对结果进行左循环移位b位。
>
> ​				4）将H~0~~H~4~复制到变量A~E中
>
> ​				5）进行80次迭代，每次迭代修改A~E变量的值
>
> ​				6）将迭代完成后的A\~E变量与H~0~~H~4~对应相加
>
> 第5步中的C代码表示如下
>
> for(i=0;i<80;i++){
> 	temp=S^5^(A) + f~i~(B,C,D) + E + W~i~ + K~i~ ;    // 每次的temp会修改A，A影响B，B影响C，C影响D，D影响E
>
> ​	E = D; D = C ; C = S^30^(B) ; B = A; A = temp;
>
> }
>
> 上述代码中K~i~常量由标准定义，函数f~i~定义如下
>
> ​		f~i~(B, C, D) = (B AND C) OR (NOT B AND D) (0<= i<= 19)
>
> ​		f~i~(B, C, D) = B XOR C XOR D (20 <= i <= 39)
>
> ​		f~i~(B, C, D) = (B AND C) OR (B AND D) OR (C AND D) (40<=i<=59)
>
> ​		f~i~(B, C, D) = B XOR C XOR D (50<=i<=79)
>
> ## **MD5算法**
>
> ​		MD5算法：将消息填补到448位，然后64位整数的原始消息长度，使得总输入长度是512位的倍数，每轮计算都用一个正在运行的128位缓存区，完全混合一个512位输入块，为了便于测量混合时使用了一个正弦函数构建的表。循环上述过程直到每个块都被处理，128缓存区里的内容就是消息摘要。
>
> ​		MD5已经被使用了很多年了，已经被人们找出具有相同散列值的冲突。因此MD5不在那么安全。

> 生日攻击
>
> ​		要想在破解一个64位的消息摘要只需要2^32^尝试即可，这个攻击思想来源于数学的概率论。由Yuval在1979年发表的论文中提到。