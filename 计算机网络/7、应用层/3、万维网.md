> 简介
>
> ​	Web诞生于1989年的欧洲原子能研究中心CERN。最初的想法是帮助大型研究所组成员通过修改报告、计划、绘图、照片的方式来进行合作。
>
> ​	伊利诺伊大学的Marc Andreessen领导开发了第一个图形浏览器——Mosaic，正式发布于1993.2。而后Andreessen离开学校组建了网景通信公司（Netscape）
>
> ​	1994年，CERN和MIT签署了建立万维网联盟（W3C，World Wide Web Consortium）的协议。W3C是一个组织，它致力于进一步开发Web

> 体系结构
>
> ​	在用户角度看，Web由分布在全球范围内的内容组成，这些内容以Web页面的形式表示。通常观看页面的程序称为浏览器。浏览器取回页面并进行解释，在屏幕上以恰当格式显示出来。
>
> ​	web基本工作模型是：**请求——响应模型**（P501图1-18），浏览器发送请求，服务器响应内容。这个过程基于一个标准协议——HTTP。请求可能是读取磁盘文档，或者是数据库查询和应用程序执行结果。如果每次显示的是一个相同的文档在，则该页面是静态页面，如果每次显示的是程序按需产生的内容，或者和页面本身包含了一个程序则称为动态页面。
>
> ​	动态页面每次显示的表现是不同的，服务器如何根据用户习惯展示不同页面的方法之一是——Cookie
>
> ​	一个页面的内容可能由几个服务器的资源提供。（应用服务器提供应用服务、资源服务器提供媒体资源）
>
> ## 	**客户端：**
>
> ​	web浏览器，用来解释网页，并且跟踪用户行为做出响应，如点击等动作。在客户端需要回答这么几个问题：
>
> ​		1、这个页面叫什么：用来唯一标识一个页面
>
> ​		2、这个页面在哪里：在哪里可以找到这个页面
>
> ​		3、如何访问这个页面：这个页面使用什么样的方式访问
>
> ​	客户端用**统一资源定位符（URL）**来解决这三个问题，URL由协议、DNS名字、指向特定页面的路径三部分组成。协议用来解决通过上面方式访问这个页面，DNS名字解决在哪里可以找到这个页面。路劲用来唯一标识一台主机内部的一个页面。
>
> （值得注意的是URL的解释权在服务器，也就是说URL中的路径可能不是一个真实的主机路径，一般为了安全考虑服务器都不会将自己真实的路径暴露出来。用户不需要关心服务器如何解析URL，主要能得到对应的页面就行）
>
> ​	客户端访问一个URL是发送的步骤：
>
> ​		1、浏览器请求DNS查询IP地址
>
> ​		2、浏览器与服务器80端口建立TCP连接
>
> ​		3、浏览器发送HTTP报文，请求页面
>
> ​		4、服务器发送HTTP响应
>
> ​		5、浏览器展示页面
>
> ​		6、短期内没有向服务器发出其他请求，那么释放TCP连接
>
> ​	URL的设计是开放式的，它运行浏览器使用多种协议去获得各种不同的资源。浏览器会根据URL中的协议类型构造对应的数据报发送给服务器。其他常见协议如下
>
> ​		http：超文本协议
>
> ​		https：安全超文本
>
> ​		ftp：FTP
>
> ​		file：本地文件
>
> ​		mailto：发送邮件
>
> ​		rtsp：实时流式媒体
>
> ​		sip：多媒体呼叫
>
> ​		about：浏览器信息
>
> ​	URL展望，用户用URL得到一个资源时，用户并不关心资源在哪，他们最关心资源的内容是否是想要的，对于被大量引用的页面，可能被分布在多个相距甚远的服务器上，URL的语义并不能实现自动获取最近的服务器资源。（这问题可以动其他办法解决，但是来的并不直接）。
>
> ​	URI统一资源标识符，用来解决URL的局限，**在URI中**告诉浏览器如何定位资源的是**URL**，只告诉浏览器资源名的是**URN统一资源名**。
>
> ## 	**MIME类型：**
>
> ​	**为了能够显示新的页面，浏览器必须了解其格式。为了让所有浏览器都了解网页，网页必须以一种标准化的语言编写——HTML。**在浏览器访问一个http协议的页面时服务器首先会发送一个HTML文档描述者页面的内容，浏览器知道怎么解释HTML文档，将文档中的图片连接、视频链接、音频链接等资源链接提取出来继续向服务器请求资源，服务器返回资源，浏览器解析这些资源放置在页面对应位置。
>
> ​	为了使浏览器能够解释服务器返回的各种资源，就需要对资源格式进行说明。这里就沿用了电子邮件中的**MIME格式对资源类型进行说明。**如：text/plain表示纯文本、text/html表示html文档。
>
> ​	一个浏览器不可能设计成可以处理各种类型资源，因为Internet在不断的发展，正确的解决方式是通过插件形式，浏览器在内部维护一张MIME表，当返回的资源格式不是浏览器自带的功能能够处理时就查看MIME表，MIME表维护资源类型和处理程序的映射，可以通过浏览器设置将一个插件（一段处理对应资源的程序代码）或者独立程序调用关联到对应的MIME格式上，浏览器在收到这种格式的资源时就交给MIME表中对应的程序进行处理。
>
> ​	插件和应用程序的区别：插件是一个第三方模块，作为拓展被安装到浏览器中，调用时享用浏览器进程的资源属于其子进程。浏览器通过一个调用将要显示的数据传递给插件，插件处理完之后将结果返回给浏览器，同时浏览器也为插件提供自身的接口，以便插件能够使用浏览器功能。常见插件：PDF、Flash、Quicktime。
>
> ​	应用程序是一个独立的进程，如Word、PowerPoint。浏览器在接收到word文档时会打开Word程序让它处理。
>
> （同理在操作系统中也有类似的MIME表，并且操作系统中的资源格式可能更多，操作系统并不会实现每个资源的处理，用户需要安装对应的处理程序，再将其设置为默认应用，就相当于在MIME表中关联了一个应用程序）
>
> ## 	**服务器端：**
>
> ​	处理请求的基本流程
>
> ​		1、接收客户端TCP链接
>
> ​		2、获取页面路径
>
> ​		3、获取页面资源或执行一个应用程序
>
> ​		4、将内容发送给客户
>
> ​		5、释放TCP链接（早期HTTP1.0时一个TCP链接只响应一个请求就被释放，HTTP1.1后TCP链接可以处理多个请求。）
>
> ​	服务器端需要处理的几个问题：
>
> ​		1、解决磁盘访问慢而导致性能瓶颈
>
> ​		2、一次只能处理一个请求，无法适应大量请求场景
>
> ​	缓存：使用缓存解决磁盘访问慢问题
>
> ​	多线程模式：服务器由一个前端模块和多个处理模块组成。处理模块属于同一进程的不同线程。这样每个处理模块都能共享地址空间中的缓存。前端模块获取一个请求创建对应语言的处理格式，将其交给一个处理模块处理。（前端充当了网关的作用，类是Apache服务器）
>
> ## 	**Cookie：**
>
> ​		用来跟踪用户。服务器能够跟踪用户可以给许多功能带来便利。如跟踪用户的访问行为，下次用户访问时在上次的断点处继续访问。如跟踪用户的购物车，保存购物车中的信息。Cookie就是用来实现这一功能的手段。提高对用户的了解可以提供更好的服务，同时也会被心怀不轨的人用来做不好的事。所有Cookie一直是一个饱受争议的技术。
>
> ​	Cookie是一个文件，服务器在响应请求的同时发送给浏览器，浏览器将其保存在本地，下一次访问同样的URL时会携带上这个Cookie给服务器，以便服务器提供区别服务。
>
> ​	Cookie文件格式：一个Cookie文件包含5个字段
>
> ​		Domain：域字段，标识这个Cookie来自哪个主机
>
> ​		Path：路径字段，域URL中的路径格式相同，表示访问哪些路径时要携带这个Cookie
>
> ​		Content：内容字段，采用键值对的形式，这个字段是Cookie中的主要内容。服务器可以设置需要的值在这个字段。
>
> ​		Expires：时限字段，表示Cookie何时过期。如果这个字段不存在则浏览器在退出时丢弃Cookie，过期时间采用标准的格林尼治时间。服务器可以通过再次发送Cookie将该字段设置为过去的时间既可以删除一个Cookie
>
> ​		Secur：安全字段，指示浏览器只向使用安全传输链接的服务器返回Cookie
>
> ​	Cookie使用实例（P510，标识用户，保存用户购买记录，跟踪用户浏览的页面）
>
> ​	跨站点跟踪：利用页面的特点和浏览器的工作原理可以实现跨站点的Cookie跟踪。当一个页面包含了来自一个广告公司的图片时，浏览器在解析到这个图片链接后会请求这个图片，而这个图片与用户访问的不是同一个站点。因为这个链接，广告公司就可以回复一个Cookie，当用户在另一个页面也存在这个广告公司的广告时，浏览器就会将上一次的Cookie携带请求这个图片，这样广告公司就可以得知用户浏览过的途径。（对于这种跨站点跟踪，浏览器一般都提供了阻止第三方Cookie的功能，浏览器可以根据用户访问的URL和Cookie中的域区分这个Cookie是否由第三方发送。）

> 静态Web页面
>
> ​	静态页面是指内容不会因为用户的不同而发生改变。
>
> ​	HTML：超文本标记语言，只标记内容，不提供内容。告诉浏览器如何展示这一部分内容
>
> ​	CSS：层叠样式表，用户美化HTML文本，单纯的标记无法满足高要求设计者的需求
>
> ​	表单：是早期HTTP提供的用户给浏览器发送数据的方式。使用get方式提交表单时用“&”分隔字段，用“+”表示空格。submit按钮触发提交表单动作。

> 动态Web页面
>
> ## 	**简介**
>
> ​		随时web的广泛应用，web的便捷体验使得人们不满足于查看资源想用web做更多的事情，比如将其用作应用程序完成一些服务。如：在线股票信息查询、在线视频观看等，这些服务用传统的应用程序可以实现，如果由web来实现这些功能就能使得用户免去安装和管理大量不同APP的工作。提供了一个统一的入口去使用各种服务，这种模式就是云计算的普遍形式。这样的展望使得web应用快速的发展。
>
> ​		为了运行应用程序，Web页面就不能再是静态的了。根据Web工作模型——“请求响应”，可以在客户端、服务器两个位置实现动态页面。举一个地图服务的例子，用户输入一个地址浏览器发送请求给服务器。服务器将根据请求的地址给出对应的地理信息**（服务器端的动态页面，根据请求的内容进行动态响应）**，浏览器收到响应后显示内容，在浏览器端用户可以通过放大和缩小等操作查看信息地理信息和宏观地理信息。这个动作可以不触发再次请求，直接由客户端的程序完成**（客户端动态页面，根据用户的行为进行动态变化）**。当用户拖动地图查看其他区域时客户端本地可能没有这个区域的信息，而用户想要页面能够自动的显示这一块区域的信息而不是再次输入地址查询，这就要求页面能够根据用户的需求自动发起请求，并响应内容到原有页面上**（AJAX，这个技术使得页面更加人性化，就好像一个与人互动的生物，而不是按照用户一步步指令进行操作的机器）**
>
> ## 	**服务器动态页面生成**
>
> ​		究竟如何在服务器上运行一个程序而不是检索一个文件取决于web服务器的设计，web协议本身没有说明。因为接口可以时专有的，浏览器并不需要知道里面的细节，它仅仅负责发出请求获取页面。
>
> ​		为了使Web服务器能够调用程序，已经开发出了标准的API，这些接口的存在使得开发人员更加容易地把不同的服务器扩展到web应用程序。下面介绍两种API
>
> ​		**公共网关接口（CGI，Common Gateway Interface）**：由RFC3875定义。CGI提供一个接口允许Web服务器与后端程序及脚本通信，后端程序接收Web服务器的输入信息，并生成HTML作为响应。这个后端程序可以由任何开发者喜欢的语言编写。
>
> ​		**第二种API**：是在HTML页面中嵌入脚本，让服务器执行这些脚本并发送给客户端。由于脚本的存在蓑衣使得页面的内容可以根据请求动态变化。在服务器中这些内嵌脚本的Web页面使用特殊的格式标识而不是以.html结尾。如用PHP作为脚本语言则页面文件为.php，用java作为脚本语言则页面文件为.jsp。浏览器在处理这些页面请求时会执行页面中的代码在返回.html格式的文件。
>
> ​	（其他服务器端动态页面生成的方法还有很多，如微软的APS.NET、Python的Django等）
>
> ## 	**客户端动态页面生成**
>
> ​		PHP和CGI实等后端技术实现了服务器端的动态页面，当这些页面并不能跟踪客户端的用户行为，如鼠标移动等事件，为了达到这个目的有必要在html页面中嵌入脚本，而且这些脚本必须能够在客户端上运行而不是在服务器端。
>
> ​		从HTML4.0开始可以通过\<script>标签来嵌入脚本，用来产生和用户行为的交互，这些技术称为动态HTML（Dynamic Html）。用于客户端的脚本语言很多其中最常用的时Javascript。
>
> ​		**Javascript：**使用Javascript的html页面能够动态的改变页面这些动作可以在客户端本地完成不需要与后端进行交互。
>
> ​		**Applet：**用于客户端页面动态变化的技术还有其他方式如小程序（Applet）这些用java编写的小程序被编译成虚拟机的机器指令，这里的虚拟机是java虚拟机（JVM）。这些小程序被嵌入到HTML的\<applet>标签中被具有JVM能力的浏览器解释执行。由于这些程序是被解释施行的，因此Java解释器可以防止它们做坏事。
>
> ​		**ActiveX控件：**ActiveX控件时Microsoft对于Sun公司java小程序的一个回应。ActiveX是一种被编译程x86机器指令的程序，可以直接在裸机上执行。
>
> ​		这三个技术的比较：Javascript最容易编写也是浏览器支持最广泛的，java小程序运行速度比javascript快移植性比javascript好，ActiveX速度最快移植性最差。
>
> ## 	**AJAX**
>
> ​		在客户端和服务器都具有生成动态页面的能力后，需要由一种技术将这两个能力结合起来更加充分的发挥它们的能力。完成更加人性化的功能。
>
> ​		AJAX表示一种语义，它是一组技术的组合，这些技术互相合作完成丰富的功能。这些技术包括：
>
> ​		1、HTML、CSS
>
> ​		2、DOM模型
>
> ​		3、前后端数据交互的技术XML
>
> ​		4、程序发送和检索XML数据的异步方式
>
> ​		5、将所有功能组合在一起的Javascript
>
> ​		DOM：文档对象模型，将web页面模型化，使得程序语言可以通过操作模型实现页面的改变。
>
> ​		XML：可扩展标记语言，用来传输格式化数据，与平台无关，可以跨平台交流。XML不仅仅用在Web服务，也可以用在C-S架构的应用程序中。
>
> ​		XSLT：可扩展样式表语言转换，是XML文档的的CSS
>
> ​		Javascript：网页脚本语言，用来结合上述各种技术，实现异步I/O交互XML，使得客户端在等待XML时不会阻塞用户对页面的操作。

> Http协议
>
> ## 	**简介**
>
> ​		HTTP用于WEB服务器和客户端之间传输信息。它运行在TCP之上，内置的的端口号是80。它指定了客户端可能会发送给服务器什么样的消息，已经可能会得到的响应形式。请求头和消息头以ASCII码形式给出，和SMTP协议一样消息内容具有一个类是MIME的格式。HTTP不仅限于Web浏览器和服务器之间使用，它还可以用于媒体播放器与服务器之间的传输。这使得HTTP更像是一个传输层协议，用来实现进程直接的通信。现在可以在各种软件上看到HTTP的身影。
>
> ## 	**连接**
>
> ​		浏览器和服务器联系最常用的方式就是在80端口上建立TCP连接，这个过程不是不许要求的，使用TCP连接可以让上层应用不用担心如何处理长消息、可靠性、拥塞控制等。
>
> ​		**HTTP1.0：**一个TCP连接只用来传递一个响应即被释放，后续请求需要重新建立TCP连接，因为早期都是静态的页面，所有内容的请求大多都是一次性完成的。
>
> ​		**HTTP1.1：**支持持续连接，一个TCP连接可以多次的发送请求和接收响应，这种策略也被称为**连接重用**，而且还可以**发送流水线请求**（即一个请求可以在上一个响应来临之前发送出去，请求的发送不受限于响应是否到来，这使得整个连接过程的请求看起来像一条流水式的发送）
>
> ​		HTTP1.0下的连接效率低于HTTP1.1下的等-停式效率：区别在于每次TCP连接都需要开销并且TCP需要慢启动
>
> ​		HTTP1.1下的等-停式连接效率低于HTTP1.1下的流水线方式：减少了等待响应的间隔时间
>
> （三种方法的比较图P530，图7-36）
>
> ​		另外还有一种同时打开多个TCP连接的并行连接方式，这种方式效率比顺序连接要高，缺点式额外开销大，并且不同TCP连接之间各种进行拥塞管理，造成彼此之间竞争。
>
> ## 	**方法**
>
> ​		HTTP是为web而设计的，但设计时有放眼未来面向对象的的使用，所以HTTP不仅仅支持WEB请求，还支持更加普遍的操作——**方法**
>
> ​		HTTP的每一个请求由一行或多行ASCII码组成，第一行的第一个词是被请求的方法名。方法名区分大小写，下列是内置的HTTP方法
>
> ​		GET：读取一个Web页面
>
> ​		HEAD：读取一个WEB页面的头（报文头），可以用来测试URL的有效性
>
> ​		POST：附加一个WEB页面
>
> ​		PUT：存储一个WEB页面，往服务器写入页面，请求方法后往往包含认证头
>
> ​		DELETE：删除一个WEB页面，删除服务器中的页面
>
> ​		TRACE：回应入境请求，用于调试，它会发回用户发出的请求，以便观察请求报文
>
> ​		CONNECT：通过代理连接
>
> ​		OPTIONS：一个页面的查询选项
>
> ​		**响应：**每个请求都会返回一个响应，响应消息由一个状态行和可能的附加消息（响应头响应体）
>
> ​		**状态码：**状态行中包含3位数的状态码，状态码表示该请求是否被满足，不满足的原因是什么。
>
> ​			1xxx：消息，服务器同意处理客户请求
>
> ​			2xxx：成功，200=请求成功，204=没有内容
>
> ​			3xxx：重定向，301=移动页面，304=缓存页面仍然有效
>
> ​			4xxx：客户错误，403=禁止访问，404=页面没找到
>
> ​			5xxx：服务器错误，500=服务器内部错误，503=稍后再试
>
> ## **消息头**
>
> ​		每个HTTP请求除了方法外还可能包含其他行，其中包含了这次请求所需的更多信息，它们同称为请求头。响应消息也有类似的响应头
>
> ![image-20210406115234877](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210406115234877.png)
>
> ## 	**缓存**
>
> ​		积攒已经获取的网页供日后使用的处理方式称为——缓存。缓存可以减少不必要的HTTP请求，HTTP协议对缓存技术给予了支持。如消息头部的，Cache-Control、ETag、IF-Modified-Since、IF-None-Match、Last-Modified、Expires等字段。
>
> ​		HTTP缓存的难点在于如何判断过去缓存的页面和将要请求的页面是相同的。这一点无法从URL中体现。HTTP使用两种策略来解决。
>
> ​		第一种策略，**页面验证**：访问一个URL时浏览器先检查缓存中是否保存了该URL的页面，若有并且新鲜则使用缓存，页面是否新鲜由页面响应头中的**Expires字段**决定。若响应的页面中没有Expires字段则浏览器会根据**Last-Modified字段**启发式的判断是否使用缓存，若Last-Modified字段显示该页面最近一次修改在一年前，则近期很可能不会修改，可以使用。
>
> ​		第二种策略，**条件GET**：单一的由浏览器判断缓存是否有效使用起来总是不尽人意，所以可以让服务器也加入进来判断。浏览器判断一个缓存是否过期时会给服务器发送一个**条件GET**询问缓存是否有效，服务器回应有效或者新的页面。
>
> ​		条件GET实现一种方式是请求头中的**If-Modified-Since**，表示只从整个时间点后页面是否发生修改。
>
> ​		另一种实现条件GET的方法是利用消息头中的**ETag字段**，服务器在初次响应页面时在响应头中携带ETag字段，字段值是一个被签名的页面哈希值，浏览器在判断缓存有效性时将该哈希值包含在请求头中的**If-None-Match字段**中，服务器接收并检查页面哈希值后响应有效或者新的页面。
>
> ​		**Cache-Control字段**：该字段可以覆盖以上两种缓存策略，它决定了页面是否可以被缓存。
>
> ​		**缓存的位置：**缓存不仅仅实现在客户端，也可以实现在HTTP请求的沿途设备上，这种缓存称为代理缓存，后面的CDN（内容分发网络，Content Distribution Network）将会提及。
>
> ​		

> 移动Web
>
> ​		移动web的特点
>
> ​			1、屏幕较小，无法显示大图像
>
> ​			2、有限的输入能力，使得URL的输入较为麻烦
>
> ​			3、无线链路的带宽限制，3G、4G网络的收费
>
> ​			4、网络的连通性断断续续
>
> ​			5、电池寿命、散热等导致计算能力有限
>
> ​		移动终端的特点导致难以把台式机的页面直接应用在移动端。移动Web早期使用有一种专门的协议栈WAP（无线移动应用），而后由于计算机网络的快速发展，速度和带宽不再是移动终端的瓶颈时，移动web应用的协议和台式机基本一致。然而服务器依然需要为移动终端请求的页面进行处理。
>
> ​		一种是移动终端单独设计页面：服务器根据请求头中的User-Agent可以判断出是否为移动设备上的浏览器，若是则返回移动端的页面
>
> ​		一种方法是内容转换：将台式设备的页面内容转换为移动设备合适的尺寸。

> Web搜索
>
> ​		Web搜索是众多Web应用中最出众的。它使得人们可以根据想要的内容检索到可能的页面，而不是输入URL。毕竟初来者并不知道这个URL中有什么东西。
>
> ​		Google是web搜索的代表作之一，最初创造者的思想是一个页面多少次被其它页面指向是评价页面重要性的更好手段，比每个页面包含多少关键词更好。这个想法也是Google在当时众多搜索引擎中脱颖而出的关键之一。