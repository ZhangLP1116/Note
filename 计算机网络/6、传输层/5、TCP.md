> TCP服务模型
>
> ​	TCP在建立连接的基础上进行数据传输，TCP的连接时全双工的，并且是点到点的，TCP不支持组播或广播。
>
> ​	TCP连接是一个字节流而不是消息流。端到端之间不保留消息的边界。如果发送进程将4个512字节的数据块写到一个TCP流中。那么这些数据可能按4个512字节块、2个1024字节块、1个2048字节块或其他方式被递交给接收进程。
>
> ​	**TCP_NODELAY：**当一个应用将数据传递给TCP是，TCP 可能立即将数据发送出去、也可能将它缓存起来收集更多的数据一起发送。这时TCP为了更有效的利用带宽的机制。然而这个机制对于一些交互式的游戏来说并不友好，可能会带来不好体验的延迟，所以就有了一个强制TCP发送数据的机制，TCP由个PUSH标志位，写带PUSH标志位的数据段告诉TCP不要延迟传输。应用程序不能直接设置PUSH标志位，只能通过操作系统调用设置。
>
> ​	urgent data：紧急数据，TCP头部中有一个紧急指针位。该位有一个特点就是设置了改位的数据段将会被立即发送，并且接收端会立即处理这个数据段。

> TCP头（P429）

> TCP连接建立（P432）

> TCP连接释放（P433）

> TCP连接管理模型
>
> ​	TCP状态机
>
> ​	CLOSED：没有活跃的连接或挂起
>
> ​	LISTEN：服务器等待入境呼叫
>
> ​	SYN RCVD：到达一个连接请求，等待ACK
>
> ​	SYN SENT：应用已经启动了打开一个连接
>
> ​	ESTABLISHED：做出的数据传输状态
>
> ​	FIN WAIT1：应用没有数据要发送了
>
> ​	FIN WAIT2：另一端同意释放连接
>
> ​	TIME WAIT：等待所有数据包寿终正寝
>
> ​	CLOSEING：两端同时试图关闭连接
>
> ​	CLOSE WAIT：等待另一端发起关闭连接
>
> ​	LAST ACK：等待所有数据包寿终正寝
>
> 每个状态机都有对应的事件触发，状态机变迁如（P435图6-39）

> TCP滑动窗口
>
> ​	TCP的窗口管理将正确接收段的确认和接收端缓存区分配分离。
>
> ​	延迟确认：为了避免单独发送一个确认数据包浪费带宽，TCP采用延迟确认的方法，使得确认信息可以搭载到后续要发送的数据包中。
>
> ​	Nagle算法：在一些远程命令交互的服务中如SSH、telnet，使用TCP建立连接并且每次敲击一个字符都会做出响应，发送一个41字节的数据包（20字节TCP头，20字节IP头，1字节数据）会带来大量的带宽浪费。Nagle算法建议每次数据以很少量进入到发送端时，发送端只发送第一次达到的数据，将后续到达的字节缓冲起来，直到发送出去的数据包被确认。在一些对延迟敏感的交互性游戏中可以使用TCP_NODELAY禁用Nagle算法。
>
> ​	低能窗口综合症：发送端一次性发送大量数据包，接收端交互式应用每次只读取一个字节数据，TCP每次只对一个字节进行确认，导致发送端每次只能发送一个字节，对带宽的使用效率底下。
>
> ​	Clark方法：TCP禁止接收端发送止只有以字节的窗口更新。它强制TCP必须等待一段时间，直到有了一定数量的空闲空间后在发送确认。
>
> ​	（接收端还可以通过阻塞上层应用程序的READ请求，直到它累计了大块的数据，这样有利于减少TCP调用的次数。）

> TCP时间管理
>
> ​	重传计时器：设置数据段重传时间间隔，计算方法P439
>
> ​	持续计时器：避免出现死锁
>
> ​	保活计时器：定时发送心跳以在空闲时刻维持TCP连接
>
> ​	终止连接计时器：TCP连接使用的最后一个计时器，用于连接的终止阶段。是TIMED_WAIT状态使用的计时器，超时值位两倍于最大数据包生存周期。保证连接终止后连接上的数据包都已失效。

> TCP拥塞控制
>
> ​	TCP通过维护一个拥塞管理窗口来进行拥塞管理。
>
> ​	TCP通过序列号和确认号来跟踪拥塞窗口，并使用AIMD规则调整窗口大小。在整个传输链路中，传输速度取决于最小链路上的速度，TCP发送小的突发数据包，在接收到确认时由于最小链路的缘故数据包传递到发送端会保持最小链路的时序，这也就可以测试出该以什么样的速度发送数据包，进而调整拥塞窗口进行发送速率的控制。
>
> ​	**慢速启动：**由于AIMD法则的特点使得TCP拥塞窗口从一个小规模开始到达一个良好的操作点需要很长时间。Jacobson提出一种线性增长和乘法增长混合的方法。这种方法被称为慢速启动。慢速启动使得拥塞窗口按指数增长，为了避免无限的增长需要设置一个阈值，一开始阈值可以设置的很高，一旦发生拥塞就将阈值设置为当前的一半。
>
> ​	**重复确认：**TCP中由于重传等待的时间设置的较长，所以接收端收到一个丢失的数据包需要较长的时间，但接收端又不能越过它进行确认。所以需要一个机制加快重传。在接收端因为丢失数据包，确认序号会被卡在上一个值，并且重复多次。接收端就可以通过这个特点进行判断，一般认为收到3次重复确认认为包丢失，立刻重传数据包，这被称为——**快速重传**。
>
> ​	**快速回复：**由于数据包的重传会导致TCP慢速启动，每次慢启动都会影响到用户的使用，而快速重传机制就可能导致多次的慢启动现象，而这时可能只是数据包的偶尔丢失并没有发生网络拥塞。快速回复就是这样一个解决方法，它是一个临时模式，在发生丢包后，将拥塞窗口设置为一半，发生速率并不归零，在进入快速回复状态时TCP将持续检测丢包，若后续没有发生大量丢包则退出快速回复。若发生大量丢包则进入慢启动。（P446图6-47）
>
> ​	**选择确认：**累计确认只能让发送方得知后一个数据包丢失，若由多个不连续包丢失则需要多次累计确认才能完成重传。选择确认则是列出3个已经接收的字节范围，使得发送方可以一次性知道哪几个包需要重传（P447图6-48） 
>
> ​	**显示拥塞通知：**除了丢包作为拥塞信号之外，显示通知的使用使得TCP可以更准确的调节拥塞窗口。ECN时IP层的机制用来通知主机发送了拥塞。TCP中可以通过ECN字节来得知。

> TCP未来
>
> ​	1、TCP没有为应用程序提供所需的传输语义，如有些应用程序需要保留其发送的消息。有些需要更好的控制它们使用的网络路径。标准的TCP套接字并不满足这些需求。这就导致了学者提出稍微不同接口形式的新协议。如流控制传输协议（SCTP）和结构化流传输（SST）
>
> ​	2、拥塞控制，随着链路水平的发展，丢包现象越来越少，倒是网络拥塞并没有随着减少。这就是的以丢包作为拥塞判断的TCP协议显示有些迟钝了。这就导致许多人重写拥塞管理