### 消息确认

消费者应用（Consumer applications） - 用来接受和处理消息的应用 - 在处理消息的时候偶尔会失败或者有时会直接崩溃掉。而且网络原因也有可能引起各种问题。这就给我们出了个难题，`AMQP代理在什么时候删除消息`才是正确的？AMQP 0-9-1 规范给我们两种建议：

- 当消息代理（broker）将消息发送给应用后立即删除。（使用AMQP方法：basic.deliver或basic.get-ok）
- 待应用（application）发送一个确认回执（acknowledgement）后再删除消息。（使用AMQP方法：basic.ack）

前者被称作`自动确认模式（automatic acknowledgement model）`，后者被称作`显式确认模式（explicit acknowledgement model）`。在显式模式下，由消费者应用来选择什么时候发送确认回执（acknowledgement）。应用可以在收到消息后立即发送，或将未处理的消息存储后发送，或等到消息被处理完毕后再发送确认回执（例如，成功获取一个网页内容并将其存储之后）。

如果一个消费者在尚未发送确认回执的情况下挂掉了，那AMQP代理会将消息重新投递给另一个消费者。如果当时没有可用的消费者了，消息代理会死等下一个注册到此队列的消费者，然后再次尝试投递。



### 拒绝消息

当一个消费者接收到某条消息后，处理过程有可能成功，有可能失败。应用可以向消息代理表明，本条消息由于“拒绝消息（Rejecting Messages）”的原因处理失败了（或者未能在此时完成）。当拒绝某条消息时，`应用可以告诉消息代理如何处理这条消息——销毁它或者重新放入队列`。当此队列只有一个消费者时，`请确认不要由于拒绝消息并且选择了重新放入队列的行为而引起消息在同一个消费者身上无限循环的情况发生`。



### 预取消息

在多个消费者共享一个队列的案例中，`明确指定在收到下一个确认回执前每个消费者一次可以接受多少条消息是非常有用的`。这可以在试图批量发布消息的时候起到简单的负载均衡和提高消息吞吐量的作用。For example, if a producing application sends messages every minute because of the nature of the work it is doing.（例如，如果生产应用每分钟才发送一条消息，这说明处理工作尚在运行。）

注意，`RabbitMQ只支持通道级的预取计数`，而不是连接级的或者基于大小的预取。



```java
// 确认消息，可批量确认
basicAck();
// 否定确认消息，可批量拒绝，是否重新放入队列
basicNack();
// 拒绝消息，是否重新放入队列
basicReject();
```

