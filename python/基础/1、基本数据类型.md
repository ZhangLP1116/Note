**python采用基于值的自动内存管理模式，变量并不直接存储值，而是存储值的引用或内存地址。**

> **字符串**
>
> 由成对的单引号或者双引号构成或三眼号包围
> 	如：a = 'hello world'，b = "hello world"
> 	常用方法：
> 	.title()：将字符串中的每个单词首字母大写
> 	.upper()：将字符串中的每个字母大写
> 	.lower()：将字符串中的每一个字母小写
> 	.rstrip()：将字符变量串末尾的空格删除
> 	.lstrip()：将字符串开通的空格删除
> 	.strip()：将字符串首尾的空格删除
> 	.split()：将字符串转换成列表，默认以空格为分隔标志
> 	str()：将变量转换成字符串类型

> **数值型**
>
> 可以进行算数运算的一类变量，常见的有int，float
>
> 常见运算符+(加)、-(减)、*(乘)、\（除）、%（取余）、**（乘方）、\\（整除）
>
> ps：python中的除法运算和C语言中相似，除号两边都为整形时则为整除，若任意一边为float类型时则为精确运算
>
> 常用方法：
>
> int()：将变量转换成整形
>
> float()：将变量转换成浮点型

> **列表**
>
> 存储一组数据的变量类型，其中的元素可以是字符、数字、实例、字典、元组等，用[]方括号表示
>
> **列表的增删改查：**
>
> 用例：b = ['a', 'b']
>
> 1、访问列表中的元素
>
> 使用索引访问列表中的元素，索引从0开始。
>
> b[0]
>
> 2、修改列表中的元素
>
> b[0] = 'c'
>
> 3、增加列表中的元素
>
> 在列表末尾加入：b.append('c')
>
> 在列表中插入：b.insert(0,'c')，需要参数：索引位置，插入值。插入位置开始的每一个元素都将向右移动一位
>
> 4、删除列表中的元素
>
> del：del b[0]
>
> b.pop()：默认删除末尾元素，并返回删除的值，可以指定位置，如：b.pop(0)，a = b.pop(0)
>
> b.remote('a')：删除指定内容元素
>
> **切片：用于创建列表的副本**
>
> **利用切片取值**
>
> b[:]：从头到尾
>
> b[:n]：从头到n-1的位置
>
> b[1:]：从1到尾
>
> b[-2:]：从倒数第二到尾
>
> **利用切片增加元素**
>
> b[len(b): ] = [9]	：在列表尾部插增加元素
>
> b[ :0] = [1,2]	：在列表头部插入多个元素
>
> b[3 : 3] = [4]	：列表中间插入元素
>
> **利用切片修改和替换列表中的元素**
>
> b[ : 3] = [1,2,3]	：修改前三个列表中的元素值，替换列表时等号两边列表长度要相等
>
> b[3 : ] = [4,5,6]	：等号两边长度不一致就变成了增加或删除元素
>
> b[ : : 2] = [0] * 3	：隔一个修改，切片不连续时等号两边长度必须一致，不然会抛出异常
>
> **列表的遍历**
>
> for i in range(1,10):（表示循环从1开始到n-1结束）
>
> for i in b:（表示遍历整个列表）
>
> **列表的排序**
>
> b.sort()：对列表b根据字母顺序进行永久性的排序，（传入形参reverse=True，可以根据字母顺序逆序排序）
>
> sorted(b)：对列表进行临时性的排序，如：print(sorted(b))，同样可以传入reverse=True
>
> b.reverse()：将列表反向排序
>
> **列表解析**
>
> b = [vaule for vaule in range(1,9)]：由列表名，表达式，for循环三部分组成
>
> 使用列表解析实现矩阵转置
>
> ```python
> matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
> matrix_T = [[row[i] for row in matrix] for i in range(4)]
> 
> # 上述列表推导式等价于下面代码
> matrix_T = []
> for i in range(4):
>     temp = []
>     for row in matrix:
>         temp.append(row[i])
>     matrix.append(temp)
>     
> # 使用内置函数实现转置,*matrix序列解包，相当于传入位置形参
> list(map(list, zip(*matrix)))
> ```
>
> **列表的常用方法**
>
> 1、len(b)：计算列表实际长度
>
> 2、s = ''.join(b)：将列表转换为字符串
>
> 3、list(range(1,9))：生成一个1到8的列表
>
> 4、append(x)：将x追加到列表尾部
>
> 5、extend(L)：将列表L中的所有元素追加到列表尾部
>
> 6、insert(index, x)：在列表任意位置插入，索引可以为负数
>
> 7、count(x)：计算x在列表中出现的次数
>
> 8、index(x)返回x元素在列表中的索引值，首次出现的位置
>
> **列表与for循环**
>
> 当for循环在遍历某一列表时，不可以在循环体内对该列表进行修改，这样会影响for循环的组成运行
>
> **列表与函数**
>
> 当列表以变量名形式传递给函数时，函数对列表的改变会影响的列表本身。如不想列表本身的元素被修改则可以使用**切片的形式传递**列表的副本，这样既传递了列表的元素又不会使自身的元素遭到修改
>
> **列表的浅复制**
>
> 列表对象的copy()方法返回的列表就是浅复制列表，浅复制是指生成一个新列表，并把原来列表中所有元素的引用复制到新列表中。浅复制会导致一个现象，当原列表汇总引用对象值改变时会影响到新列表中的值。
>
> ```python
> x = [1,2,[3,4]]
> y = x.copy()
> >>>y
> y[2].append(5)
> [1,2[3,4]]
> x[0] = 6
> y.append(6)
> >>>y
> [1,2,[3,4,5],6]
> >>>x
> [6,2,[3,4,5]]
> 
> # 可以看到当y浅复制了x时，y列表改变第三个元素中的值时，x列表中第三个元素值也发生改变，这是因为x中第三个元素为列表，其保存的是列表的引用，当y浅复制是直接复制了该引用，所以修改该元素时会影响到x中的该元素
> # 修改非引用元素值时不会影响原列表
> ```
>
> **列表的深复制**
>
> 深复制是指对原列表中的元素进行递归复制，把所有元素都复制到新列表中，对于嵌套列表不再是复制引用，而是递归复制其中的值。
>
> ```python
> import copy
> 
> x = [1,2,[3,4]]
> y=copy.deepcopy(x)
> ```
>
> **列表变量之间的赋值**
>
> ```python
> x = [1,2,[3,4]]
> y = [1,2,[3,4]]
> # 上面相当于两个列表，其中任何一个列表的修改都不会影响到另外一个列表
> 
> x = [1,2,[3,4]]
> y = x
> # 上面代码是将一个列表同时赋值给了两个元素，其中任何一个变量对列表的修改都会影响到另外一个变量
> ```
>
> 

> **元组**
>
> 元组是一种轻量级列表，**如果元组中只有一个元素则必须在元素后加上一个逗号**
>
> 元组与列表的区别：
> 1、元组属于不可变序列，只能在生成的时候赋值，创建完之后其中的元素无法被改变。也无法增加或删除元素
> 2、python内部对元组做了大量的优化，访问速度比列表更快

> **字典**
>
> 由花括号包裹起来的一系列键值对，字典中的键可以是python中任意不可变数据（整数、实数、复数、字符串、元组等），不能使用列表等可变类型作为字典的键且字典的键不允许重复。字典内部属于哈希表结构，检索元素非常快。字典的值可以是任何类型，并且可以重复。
>
> 用例：s = {‘a’:  ‘b’,'c': 'd'}
>
> **字典的增删改查**
>
> 1、增加键值对
>
> s.[e] = 'f'：增加新的键值对‘e’ :‘f’
>
> 2、访问值
>
> s.[a]：访问a的值
>
> s.get(name)：使用get()方法输入key查询value
>
> 3、修改值
>
> s.[c] = 'z'：修改c的值
>
> 4、删除键值对
>
> del s.[e]：删除键值对‘e’: ‘f’
>
> **字典的遍历**
>
> for key in s：遍历字典元素，默认对key进行遍历
>
> for key, value in s.items()：遍历键值对
>
> for i in s.keys()：返回一个包含所有键的列表，遍历所有键
>
> for i in s.values()：返回一个包含所有值的列表，遍历所有值
>
> **字典的嵌套**
>
> 字典的值可以是列表，也可以是字典

> **集合**
>
> 属于python无序可变序列，使用花括号作为定位符，元素之间使用逗号隔开，集合中的元素不允许重复。集合只能包含不可变类型数据，不能包含可变类型数据。
>
> 集合也使用哈希表存储元素，索引速度非常快。
>
> **常用方法：**
>
> set()：函数将可迭代对象转换为集合。
>
> add()：方法在集合中添加在集合中添加新元素，自动忽略重复元素
>
> update()：方法合并一个集合到该集合中，自动忽略重复元素
>
> pop()：方法随机删除集合中的元素并返回，若不存在则抛出异常
>
> remove()：方法删除集合中的指定元素，若不存在则抛出异常
>
> discard()：方法从集合中删除指定元素，若不存在则忽略该操作
>
> clear()：方法清空集合
>
> **集合运算符：**（关系运算符作用在集合之间时表示集合之间的包含关系而不是大小比较关系。）
> 1、并集，|
> 2、交集，&
> 3、差集，.difference()方法
> 4、真子集，A<B
> 5、子集，A<=B

> **python序列分类**
>
> **按有序无序分类**
>
> 有序序列：列表、元组、字符串
>
> 无序序列：集合、字典
>
> **按是否可变分类：**
>
> 可变序列：列表、字典、集合
>
> 不可变序列：元组、字符串

> **生成器推导式**
>
> python中常见的推导式有列表推导式，字典推导式，集合推导式和生成器推导式。
>
> 生成器推导式使用圆括号包裹，推导式的结果是一个生成器对象，具有惰性求值的特定，只有在需要的时候才生成新的元素，占用空间非常小。生成器对象可以使用for循环迭代，和可以使用对象自身的next()方法进行遍历。

> **序列解包**
>
> 顾名思义，就是将序列化类型的变量拆分。
>
> 序列解包可以作用与列表，元组，集合字典等常见的序列对象，也可以作用于emumerate对象、filter对象、zip对象、生成器对象等可迭代对象。序列解包作用在字典上时默认对字典的值进行操作。
>
> 元组解包：x,y,z = ('a', 'n', 'm')
>
> 列表解包：x,y,z = ['a', 'n', 'm']
>
> 集合解包：x,y,z = {'a', 'n', 'm'}
>
> 字典键解包：x,y,z = {'a': 1, 'n': 2, 'm': 3}
>
> 字典值解包：x,y,z = {'a': 1, 'n': 2, 'm': 3}.values()
>
> 字符串解包：x,y,z = 'abc'
>
> **解包的逆运算：**
>
> a,\*b,c = 1,2,3,4,5	这里\*b类似于函数中的可变长度参数，接受多个值，以列表形式保存。并且会给前后变量保留数值。
>
> **错误的解包表达式**
>
> a,b,c = *range(3)	，等号右边必须为列表元组或多个变量。
>
> **正确写法：**a,b,c = range(3) 或	a,b,c,d = *range(3), 3
>
> \*b = 1,2,3,4	，等号左边必须为列表元组或多个变量

> **常见的序列操作**
>
> **enmerate()函数**：枚举可迭代对象中的元素，返回enumerate对象，其中每个元素都是包含索引和值的元组。还可以传入第二个参数作为索引的起始值。
>
> ```python
> s = "This is is a This device"
> e_s = enumerate(s)
> print(type(e_s),e_s)
> for i in e_s:
>     print(i)
> 
> """运行结果
> <class 'enumerate'> <enumerate object at 0x0000025CC4161840>
> (0, 'T')
> (1, 'h')
> (2, 'i')
> (3, 's')
> (4, ' ')
> (5, 'i')
> (6, 's')
> (7, ' ')
> ......
> """
> ```
>
> **map()函数**：把一个函数依次映射到序列或者迭代器对象的每个元素上并返回一个可迭代对象作为结果，map()函数不对原序列或迭代器对象做任何修改。（函数的形参数有几个就要传入几个序列,序列长度不一致时以以短序列作为标准）
>
> ```python
> # 将列表中的数值转换为字符串
> s = [1,2,3,4]
> result = map(str, s)
> print(result, list(result))
> """运行结果
> <map object at 0x0000025027D16A00> ['1', '2', '3', '4']
> """
> 
> # 自定义函数作为参数
> def add(v1, v2):
>     return v1 + v2
> result = map(add, range(5), range(5,10))
> print(result)
> for i in result:
>     print(i)
> """运行结果
> <map object at 0x0000027CAC4C6F70>
> 5
> 7
> 9
> 11
> 13
> """
> 
> # lambda表达式作为参数
> s = [1,2,3,4]
> result = map(lambda x:x+1, s)
> print(result, list(result))
> """运行结果
> <map object at 0x00000133E0A46A00> [2, 3, 4, 5]
> """
> ```
>
> **filter函数：**将一个单参数的函数作用在一个序列上，并返回该序列中返回值为True的那些元素组成的filter对象。如果指定函数为None则返回序列中等价于True元素。（只需要一个序列，并且函数的形参也只能有一个）
>
> ```python
> # lambda表达式作为参数
> s = [1,2,3,4]
> result = filter(lambda x:x>2, s)
> print(result, list(result))
> """输出结果
> <filter object at 0x00000213D2EC6A00> [3, 4]
> """
> 
> # None作为参数
> s = [0,1,2,3,4]
> result = filter(None, s)
> print(result, list(result))
> """输出结果
> <filter object at 0x000001BF84416FA0> [1, 2, 3, 4]
> """
> 
> # 自定义函数作为参数
> def func(x):
>     return x.isalnum()
> 
> s = ['0','1','2','3','4','a@!#!@#']
> result = filter(func, s)
> print(result, list(result))
> """运行结果
> <filter object at 0x0000022E534786D0> ['0', '1', '2', '3', '4']
> """
> ```
>
> **reduce()函数：**标准库functools中的函数reduce可以将接收两个参数的函数以迭代累积的方式从左到右依次作用在一个序列或迭代器对象的所有元素上,返回累积结果。（两个形参只对应一个可迭代对象，**实现累积功能**）
>
> ```python
> from functools import reduce
> 
> # 实现字符连接
> def func(x,y):
>     return x+y
> 
> a = ['a','b','c','d']
> result = reduce(func,a)
> print(result)
> """运行结果
> abcd
> """
> 
> # 实现累加
> def func(x,y):
>     return x+y
> 
> a = [1,2,3,4]
> result = reduce(func,a)
> print(result)
> """运行结果
> 10
> """
> ```
>
> **zip函数：**将多个可迭代对象中的元素压缩到一起，返回一个可迭代的zip对象。其中每个元素都是包含原来的多个可迭代对象对应位置上元素的元组。最终结果中包含的元素个数取决于所有参数中最短的那个。
>
> ```python
> # 等长
> a = [1,2,3,4]
> b = ['a','b','c','d']
> result = zip(a,b)
> print(result, list(result))
> """运行结果
> <zip object at 0x00000174A0CE1B80> [(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')]
> """
> 
> # 不等长
> a = [1,2,3,4]
> b = ['a','b','c']
> result = zip(a,b)
> print(result, list(result))
> """运行结果
> <zip object at 0x000001FD76D11B00> [(1, 'a'), (2, 'b'), (3, 'c')]
> """
> 
> # 用zip和map实现矩阵转置
> matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
> result = list(map(list, zip(*matrix)))
> print(result)
> 
> """运行结果
> [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
> """
> ```
>
> 