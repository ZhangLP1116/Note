> 寄存器分配：将寄存器合理的分配给变量使用，分配后的寄存器不会出现两个正在使用的变量占用同一个寄存器。

> ## 着色问题
>
> ​		在具有冲突图的情况下对变量进行寄存器分配就是一个图着色问题（也是NP完全问题的一种），在冲突图上我们希望使用尽可能少的寄存器。对应对于任意两个相连的结点不能使用同一种颜色（存在冲突）。
>
> ​		若在一个有K个寄存器的机器上进行冲突图的着色，若K种颜色无法完成着色者称为**溢出**，这时就必须将一部分变量和临时变量存放在存储器中。

> ## 一般的着色算法
>
> 对于图着色问题存在一种能给出较好结果的线性时间近似算法，它有四个主要的阶段组成。
>
> 1. 构造：构造冲突图
> 2. 简化：
> 3. 溢出：
> 4. 选择：选择颜色给图中的结点

> ## 合并
>
> ​		利用冲突图可以很容易的删除冗余的传送指令。如果在冲突图中一条传送指令的源操作数和目的操作数之间不存在边，那么可以删除这条传送指令（不同时活跃的两个变量之间的数据传输是没有意义的）。原则上可以合并任何一对无冲突边相连的结点，实际上这种合并带来的限制非常多。下面两种合并策略是安全的。
>
> 1. Briggs
> 2. George

> ## 具有合并能力的寄存器分配方案
>
> 1. 构造
> 2. 简化
> 3. 合并
> 4. 冻结
> 5. 溢出
> 6. 选择

> ## 图着色的实现
>
> 图着色算法需要频繁的查询冲突图的数据结构，有两种查询操作
>
> 1. 获得与结点X相邻的所有结点
> 2. 判断X和Y是否相邻
>
> 使用邻接表可以快速的回答第一种查询，但是邻接表很长时却不能很快的回答第二章查询。以结点编号位索引的矩阵可以快速的回答第二种查询。所有需要同时使用两种数据结构来表示冲突图。