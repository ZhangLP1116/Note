> 活动记录：记录程序的活动情况，在程序设计中往往存在函数之间的调用，当一个函数调用另一个函数cpu会转而执行另一个函数的代码，在这个切换过程中就要对调用函数当前的变量情况、参数、返回地址等数据进行保存，才能在函数返回时继续正常执行

> ## 使用的数据结构——栈
>
> ​		根据函数的调用返回的特性：一个函数只有在它调用的所有函数返回后才能返回。是一种LIFO（后入先出）方式，所以采用栈结构可以很方便的记录函数的调用过程，确保程序正确运行

> ## 栈中的最小元素——栈帧
>
> ​		使用栈记录函数调用是要确定需要记录的数据有哪些：局部变量、返回地址、临时变量、保护的寄存器、要输出的实参。对于每一个函数在调用其他函数是都需要**保存这样一片区域的信息**，对于这样的信息将它们统称为**栈帧**，栈帧是每一个函数在调用是需要记录入栈的信息单元。

> ## 活动记录的几个要点
>
> 1. 帧指针：**帧指针指向当前函数的调用函数栈帧位置**，对于传统的栈都有一个栈顶指针指向当前栈顶，而在活动记录场景被调用函数有访问调用函数栈帧的需要，所以需要一个知道调用函数的栈帧地址，对于栈帧大小不固定的情况，帧指针是必须的，对于固定栈帧的情况，帧指针也可以简化编译器书写。（在行业内有**标准栈帧**设计，它使得不同程序设计语言编写的函数可以互相调用，缺点是对于特定语言来说栈帧不是最优结构）
> 2. 寄存器：函数的调用不可避免的需要对寄存器的值进行保存，这就涉及到了该由**调用者**还是**被调用者**进行寄存器保存的工作，称为调用者保护的寄存器，被调用者保护的寄存器。当函数f调用函数g时若变量x在调用g后不使用，则可以**将x放在调用者保护的寄存器中**（这样调用g时g可以覆盖掉x），若变量x在调用g后还要使用，则可以**将x放在被调用者保护的寄存器中**（调用g时，g会先保存x的值在覆盖该寄存器）（哪些寄存器属于调用者保护和被调用者保护在计算机设计时确定）
> 3. 参数传递：大多数调用约定设计于1970年的计算机中，函数的参数通过栈来传递。每个函数调用时将实参写入自己的栈帧中的**传出参数区域**。被调用函数如果被调用函数需要将这些参数写到存储器，则可以将它们标记到自己栈帧的局部变量区域内（局部变量包含实参和函数内定义的变量，从这可以看出实参和形参在内存中由两份数据，改变形参不会影响到实参）。
> 4. 避免存储器的访问：经统计发现很少由函数的参数超过4个，极少超过6个对于这样数量级的参数可使用寄存器来传递。**对于无法避免存储器访问的调用由以下4中方法减少存储器的访问**：（一）对于叶子过程（是一个函数调用链的终点函数，整个函数调用可以看作是一个树形结构，在树形结构中其叶子节点个数都是多余非叶子节点个数，所以大多数调用都是叶子调用）在调用是可以不用将传入的参数保存在存储器中，经常可以不用为它创建栈帧（因为他不会再有调用）（二）对于非叶子过程，其调用前有可能完全使用完参数x而不进行传递（三）优化编译器使用过程寄存器分配（四）某些体系存在寄存器窗口设计，可以充分的利用寄存器传递参数
> 5. 返回地址：是call指令地址的下一个地址，对于非叶子节点来说需要将返回地址保存在栈帧中，对于叶子节点来说不需要保存，返回地址是调用者产生，保存在被调用者栈帧中。
> 6. 帧内变量：现代的过程调用约定，函数的参数将通过寄存器传递，返回地址保存在寄存器中、函数结果保存在寄存器中返回。许多局部变量的中间结果都保持在寄存器中，很少涉及存储器的访问。但对于一些需要保存在之内的变量来说无法避免存储器的访问。**帧内变量大多属于以下类**（一）变量将作为参数地址参数，c语言中的指针变量（二）高级函数中的局部变量（三）变量值太大无法放入寄存器（四）变量是一个数组（五）存在太多局部变量和临时变量无法使用寄存器传递。（在处理程序的过程中，以到一个局部变量的声明就可以为它在寄存器或者栈帧中分配存储空间）
> 7. 静态链：是一个指针，指向包含当前函数的栈帧，多大用于闭包、地址变量等逃逸的变量。

> ![image-20210804104812432](image\image-20210804104812432.png)