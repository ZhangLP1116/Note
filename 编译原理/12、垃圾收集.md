> 垃圾收集：回收已分配的无用内存空间。

> ## 标记-清扫式收集
>
> ​		标记：程序变量和堆分配的记录构成了一个有向图，每一个程序变量是图中的一个根。沿着某个根结点r出发，构成一条路径r……n，则标记这个结点n是可达的。所有未被标记的结点都是可以清理的。（该过程可以用深度优先搜索实现）
>
> ​		清扫：将所有未标记的空间用链表连接在一起，用于下次内存分配
>
> （缺点，清理出来的内存碎片化）

> ## 复制式收集
>
> 将堆中空间分为两块，from-space和to-space，每次只在from-space中分配内存，使用广度优先搜索遍历图中可达结点，将标记的结点有序复制到to-space空间。将两个空间反转，from-space变为下次垃圾收集的to-space空间。
>
> （优点，清理出的空间连续
>
> 缺点：内存空间利用率低）

> ## 分代收集
>
> ​		经过大量实践分析，在许多程序中新创建的对象最优可能快速死去，经历一次次收集后留下来的变量往往一直活跃，所有收集器应该将注意力集中在新创建的变量上。
>
> ​		对内存进行分区：类如G0、G1、G2区，收集器重点收集G0区的垃圾，每次清理后遗留下来的变量考虑将它们移动到G1区。
>
> ​		对应创建、死亡频繁的G1区使用复制收集法，对应变动较小的高级区使用标记清理法。这是因为不同区的内存空间特点往往成指数上升，若G0区是0.5MB，则G1区是2MB，G2区8MB。在较小空间使用复制收集法对内存空间使用率影响较小，在高级区可以较少次数的使用标记清除法减少对程序的影响

> ## 增量式收集
>
> ​		传统的垃圾收集所需要的计算时间百分比较小，但收集器还是会有较长时间使中断程序运行。对于交互式程序或实时程序而言这种情况是不受欢迎的。增量式或并发式垃圾收集算法是在程序执行的同时插入垃圾收集动作，从而避免长时间的中断。