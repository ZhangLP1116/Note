0、概叙

> 并发控制，就是在数据库并发执行事务的场景下避免出现并发操作可能带来的问题。所以并发控制也可以叫做数据访问冲突控制。
>
> 其原理是在多个事务同时对一个数据进行操作时拒绝一个事务的某些操作来避免这些操作可能产生的问题。
> 也就是限制并发操作的自由度，在一定程度上使其串行执行，但又不是全部串行。

1、事务的隔离级别

> 0、概叙
>
> 隔离性是事务最重要的基本特征之一，是解决事务并发执行可能产生相互干扰问题的基本解决技术。基本思想是设置系统并行执行时的自由度等级，在一定级别下事务的一写并行操作不允许发生，从而避免这些操作可能带来的问题的。
>
> 系统变量**TRANSACTION ISOLATION LEVEL**保存当前系统设置的隔离等级

> 1、READ UNCOMMITTED（读未提交）
>
> 一个事务可以读取另一事务未提交的更新，这种隔离级别下存在**脏读**和**不可重复读**问题。但不允许一个事务在写操作的同时有另一个事务也进行写操作，**解决了更新丢失问题**
>
> **该级别下的锁原理**：写操作加X锁，读操作不加锁，直到事务结束释放X锁，**对应一级封锁协议**。读操作不加锁时，就导致写操作加的排它锁（X）无法排斥不带锁的读操作。

> 2、READ COMMITTED（读已提交）
>
> 一个事务只能读取另一事务已提交的数据，这种隔离级别下存在**不可重复读**，解决了**脏读**和**更新丢失问题**。
>
> **该级别下的锁原理**：写操作加X锁，读操作加S锁，读完释放S锁（**此时读操作的事务还未结束**），X锁在事务结束时释放，对应**二级封锁协议**。因为读完就释放S锁，所以事务还未结束时就可以有一个带X锁的写事务被执行，此时第一个事务又携带S锁想要读取数据时就会被阻塞等待写事务结束，就实现了READ COMMITTED级隔离。

> 3、REPEATABLE READ（可重复读，mysql默认隔离级别）
>
> 一个事务可以重复读取数据，事务期间该数据不会发生变化。该隔离级别下基本解决了所有并发操作可能带来的问题：不可重复读，更新丢失，脏读等。但还存在一个幻影读的情况。==（P171）==
>
> **造成幻影读的原因**：一个事务在读操作结束后，另一事务又继续了插入操作，**该隔离级别使用了障眼法的手段**，这些第二个事务所产生的变化不会被第一个未结束的事务看到。这时第一个事务在执行读操作时无法看到第二个事务对数据产生的变化，这就会误导第一个事务，使其觉得此时表没有发生任何变化，实际上已经发生了变化只是它无法察觉。这就是幻影读，这时如果第一个事务执行和第二个事务相同的数据插入操作时就会被提示主键重复的错误。
>
> **该级别下的锁原理**：这一级别下依然是二级封锁原理，但加入了**InnoDB的一个快照机制**，在一个事务开始时InnoDB会将这一时间节点的快照作为这一事务在事务期间的数据库状态，所有在其他事务对数据库发生更改时不会影响到原来事务的快照状态，也就实现了REPEATABLE READ级别，也就导致了幻影读。

> 4、SERIALIZABLE（可串行化）
>
> 强制事务排序，使得事务之间不会发生冲突。这个级别解决了所有并发操作可能产生的问题，提示也导致并发执行的速度大幅下降。
>
> **该级别下的锁原理：**在事务开始读取数据时加S锁，读取操作结束不释放S锁，直到事务结束才释放。避免了一个事务执行期间又其他事务对同一数据继续写操作的现象，也就解决了更新丢失，脏读，不可重复读问题。

> 5、总结：隔离级别越高时，并发操作可能带来的问题就越少，但并发操作的速率也会下降，所以如何取舍设置隔离级别从而达到最适合的情况，才是现场测试该解决的问题。对于大部分场景下READ COMMITTED是比较合适的一个隔离等级。
>
> ![image-20201113144207213](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20201113144207213.png)

2、锁

> **1、锁的概述：**锁实际上就是允许或阻止一个事务对一个数据对象存取权，一个事务对一个对象加锁的结果是将别的事务“封锁”在该对象之外。**一个锁总是与某一事务的一个操作相联系。**
>
> **锁的颗粒度：**封锁对象的大小称为锁的颗粒度。对象可以是**逻辑单元：**字段，记录，表，数据库；也可以是**物理单元：**页，块等。封锁颗粒越小，可封锁对象越多，影响范围越小，并发度越大，系统开销所数量增长而变大。

> **2、锁的分类：排它锁（X锁，也叫写锁），共享锁（S锁，也叫排它锁）**
>
> 排它锁：当一个事务获得一个对象的排它锁时就可以对该对象继续读写操作，并且在排它锁期间拒绝其他事务的加锁。（不带锁的操作无法拒绝，如READ UNCOMMITTED级别下的读操作是不带锁的读操作，无法拒绝）。
>
> 共享锁：当一个事务获得一个对象的共享锁是就可以对该对象继续读操作，不能继续写操作。此时拒绝其他事务对该对象加X锁，允许加S锁。

> **3、锁的相容情况**
>
> 只有S锁与S锁可以共存，其组合都不相容。

> **4、封锁协议：是一种操作规范，在事务的隔离等级中被实现**
>
> 一级封锁协议：事务在写操作之前需要获得X锁，在事务结束后释放X锁，（读操作不需要加锁）
>
> 二级封锁协议：事务在读操作之前需要获得S锁，在读操作结束释放S锁，（写操作要求为一级封锁协议内容）
>
> 三级封锁协议：事务在读操作之前需要获得S锁，在事务解释后释放S锁，（写操作要求为一级封锁协议内容）

> **5、封锁带来的问题**：
>
> **1、饿死：**在二级封锁协议情况下可能发生，一个事务想要对一个对象加X锁，在二级封锁协议要求下一个读操作之前需要加S锁，一就导致了这时X锁被排除需要等待S锁释放，但这时不断的又读操作被继续，不断的又S锁被加上，导致这个写操作的X锁一直被排斥，该事务一直处于等待状态，直到被饿死。（锁共存特点与执行循序不合理导致）
>
> 解决方法：对S锁加锁进行约束
> 	（1）：当对象上不存在等待的X锁时，可以直接加S锁
> 	（2）：当存在X锁时，按时间顺序给X锁先处理
>
> **2、活锁：**系统使得某个事务永远处于等待状态，T2事务在等待加锁时被后来的事务T3插队，又被后来的事务T4插队（导致插队的原因可能是后续的事务优先级比T2高数据库优先）。
>
> 解决方法：先来先服务的排队原则，或者每隔一段时间低优先级的事务提高优先级。（此时可以参考路由处理中的队列技术）
>
> **3、死锁：**在三级封锁协议中可能会发生，两个或两个以上事务都处于等待状态，而且互相等待对方。就陷入一个死循环，产生了死锁。（类是网络中的环路。）==（P180，表6-11）==。T1事务对一个数据对象加S锁，此时T2事务也对这个对象加S锁；这时T1想要对该对象加X锁，发现需要等待T2释放S锁，然后T2也想要对该对象加X锁，发现需要等待T1释放S锁，两个事务就进入了死锁状态
>
> 解决方法：
> 	（1）：一次加锁法，每个事务必须将所有要使用的数据对象全部一次加锁，并要求加锁成功，否则本次加锁失败，立即释放所有已加的锁。然后从头开始加锁。该方法的缺点非常明显一次性全部加锁，封锁范围大并发性降低，难以精确所有需要加锁的对象，系统开销大
>
> ​	（2）：顺序加锁：对所有可加锁的对象强加一个封锁顺序，要求事务只能以该顺序封锁对象，维护这些封锁顺序需要很大的开销。
>
> ​	（3）：mysql中常用的方法是不预防死锁，而是在死锁发生后检测并解除死锁。检测死锁的方法是利用事务等待图判断系统中是否存在死锁==（P179）==。死锁解除是将发生死锁的事务中代价最低的事务抽出并结束事务。

> **6、两段封锁协议：是一种操作规范**
>
> 两段封锁协议是一种要求并发控制达到串行性的操作规范。
>
> **两段封锁协议要求：**
> （1）：在对任意数据进行读/写操作之前，事务必须获得对数据的封锁
> （2）：在释放一个封锁后，事务不在获得任何其他封锁
>
> **两段封锁协议的解释：**将事务封锁对象分为两个阶段，第一阶段是获得封锁，也称为==“扩展阶段”==，在这阶段事务可以申请获得任何数据对象上的任何类型的封锁，但不能释放封锁。第二阶段是释放封锁阶段，也成为==“收缩阶段”==，在这个阶段事务可以释放任何数据项上任何类型的锁，但不能在申请任何锁。
>
> 实例：
> T1：S(a), x=R(a), X(b), W(b, x), U(a), U(b), C
> T2：S(a), x=R(a), U(a), X(b), W(b, x), U(b), C
>
> T：表示事务
> S：表示获取对象的共享锁
> R：表示读取操作
> X：表示获取对象排它锁
> W：表示写操作
> U：表示释放对象封锁
> C：表示提交
> 上述两个事务T1和T2中T1符合两段封锁协议，T2不符合。

> **7、MYSQL中自定义锁操作的实现**
>
> InnoDB存储引擎支持两种颗粒度的封锁：表级锁、行级锁，对于任何的表查询操作或更新操作，MYSQL都会隐式的施加表级锁。该锁的生命周期非常短，并且不受来发人员控制。
>
> **表级锁**：
>
> ```mysql
> # 添加表级锁语法格式
> LOCK tables 表名 read | write
> 
> # 删除封锁语法格式
> UNLOCK tables
> 
> # 实例
> use scott;
> lock tables account read;
> select * from account;
> 
> insert into account value('100', '1', '1')# 此时插入操作会被排斥而提示错误
> unlock tables # 解除S锁
> ```
>
> **行级锁：**
>
> ```mysql
> # 添加S锁语法
> select * from 表名 where 条件 lock in share mode
> # 添加X锁语法
> select * from 表名 where 条件 for update
> 
> # 解除行级锁，事务提交行级锁解除
> commit
> 
> # 实例
> use scott;
> start transaction;
> select * from account for update;# 给所有行加X锁
> commit # 解除锁
> ```
>
> **表的意向性锁：**
>
> **意向锁出现之前存在的麻烦：**当一个事务想要对一张表加锁之前，需要逐条检查表中是否存在互斥的行级锁。但每次这种检查都会消耗太多的系统资源。
> **意向锁的作用：**对这种情况的一直解决方法是，在事务施加行级锁时，会同时给表施加一个表级意向锁，表示该表中存在行即锁，然后可以通过意向锁的类型取判断后面要施加的标记锁会不会与行级锁相互排斥，避免了逐行查找。
>
> **意向锁的施加：**当事务在添加行级锁时，mysql会自动的向该表添加意向锁，它会在施加行级锁，并且根据行级锁的不同类型，施加不同的意向锁（IS：意向共享锁，IX：意向排它锁）。