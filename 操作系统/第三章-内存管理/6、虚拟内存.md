> **虚拟内存起因**
>
> **需求：**随着软件不断发展对内存的需求越来越大对物理内存的要求也也越来越高，但是物理内存的发展速度无法发跟上软件发展速度。对理想中的存储器要求往往与实际情况相悖
>
> ![image-20210205134327557](image\image-20210205134327557.png)
>
> **思考：**既然内存无法满足软件的大容量需求，那么能不能用存储空间更大的磁盘来存放运行中的程序呢？如果用硬盘存放运行中的程序那么要怎么解决硬盘访问速度慢的限制？

> ![image-20210205135339359](image\image-20210205135339359.png)

> **覆盖技术：**上世纪80年代，早期计算机为了解决内存不足的问题使用的一种手段
>
> **作用：**是在较小可用内存中运行较大的程序，常用于多道程序系统，与分区存储管理配合使用
>
> **原理：**将应用程序按照其逻辑结构划分成不同模块，将**不会同时运行的模块**映射到同一内存块，在按时间先后来运行。在将一些**不必要的模块**放在外存中，在需要使用的时候在load到内存中。而**经常要使用的模块**着在内存中常驻
>
> ![image-20210205141559537](image\image-20210205141559537.png)
>
> **实例：**由下图可知应用程序的总大小为190k，而内存大小只有110k无法直接存放全部的程序数据，所以这里就需要使用一些技术手段去处理，在使用覆盖技术时其内存使用情况如下。
>
> A模块为主程序，会调用其他模块，所以放在内存的常驻区域。B、C两个被A调用的模块之间又没有直接调用关系所以同时放置在覆盖区0，在下一层的模块D、E、F同理放置在覆盖区1中。
>
> 所以当该应用程序运行时，一开始只有A被加载到内存中，其后若调用B、C中的任意模块者被调用的模块加载到覆盖区0中。若C又发生函数调用E则将被调用模块放入覆盖区1中。若C又要调用F则将F放入覆盖区1中将原有的E模块数据覆盖掉。**这也就说明了为什么模块之间没有调用关系的可以被放入同一覆盖区，因为被覆盖的模块不会与将要覆盖的程序之间存在联系。而存在调用关系的模块需要放置在不同的覆盖区内，因为将原调用模块覆盖，这样会导致程序无法正常返回。**
>
> ![image-20210205142042176](image\image-20210205142042176.png)
>
> 当然分区的划分也不仅限于这一种：只要符合原理的划分都可以，另一种方法如下
>
> ![image-20210205143828099](image\image-20210205143828099.png)
>
> 覆盖技术的缺点：
>
> ![image-20210205144013486](image\image-20210205144013486.png)

> 交换技术：与交换式碎片整理原理相同，该操作由操作系统完成，减少程序员的负担
>
> ![image-20210205144343764](image\image-20210205144343764.png)
>
> 在换入换出操作中，操作系统将整个进程的内容保存到外存中去。为了保证程序运行的正确性需要将该程序当前所处的状态，也就是寄存器信息，下一条要执行的命令位置等信息都要保存在外存中去。这样才能在下次从外存中读入时正确的继续执行该程序。
>
> **进程即为正在被CPU处理的一段代码，该代码的运行环境即为当前寄存器的内存（也成为上下文），所以只要运行环境正确，不论将进程怎么移动都没有关系，只不过是代码的拷贝而已。**
>
> 交换技术中要解决的几个问题：
>
> 下如中提到的动态地址映射方法可以参考页表，页表就是一个动态的地址映射方法，它并不将一个逻辑地址直接映射到内存中，而是通过保存一个映射表实现映射，而这个表是可以动态修改的
>
> ![image-20210205145951599](image\image-20210205145951599.png)
>
> 交换技术与覆盖技术的对比
>
> ![image-20210205150417479](image\image-20210205150417479.png)

> **虚存技术：**虚拟内存管理技术，该技术的出现是因为交换技术和覆盖技术还无法达到预想的效果
>
> **出现原因：**
>
> ![image-20210205150902397](image\image-20210205150902397.png)
>
> **虚存技术的目标：**
>
> 1、解决覆盖技术要由程序员操作的难点
>
> 2、解决交换技术每个交换整个应用程序导致开销过大的难点
>
> ![image-20210205151147890](image\image-20210205151147890.png)
>
> 实现：
>
> 硬件方面支持：CPU MMU组件
>
> 操作系统支持：分页技术
>
> 应用程序支持：**程序局部性要求**，类是于页表章节提到的为了实现页表的高速访问会将页表的一小部分保存在CPU的TLB中实现快速访问，同时为了减少TLB缺失要求程序访问时要有一定的局部性使得会访问的地址都在一定的范围内，从而减少内存的访问。
>
> ![image-20210205152225021](image\image-20210205152225021.png)
>
> 程序局部性实例：
>
> 由图可知，定义的**二维数组大小为4Byte\*1024\*1024=4MB**（int类型在32位系统上占4字节），而系统中的页大小为**每页4K**，也就是说该二维数组在内存中需要1024个页才能全部存储。由C语言遍历存储特性可知，**二维数组在物理空间上的线性存储方式为以行为标准**，每一行接着每一行存储，每行的末尾的下一个地址空间即为下一行的首个元素。**所以该二维数组在该系统内存中由一个页保存一行的数组信息。**
>
> **分析图中两种程序编写**：方法一中两层循环初始化遍历以行为标准，每次循环更新一行中的一个元素。这就导致了每次更新都需要重新访问一个页，产生了一次页中断，一次页中断开销按小计算需要一次页表的查找，从按大计算就需要一次页表从外存拷贝到内存的操作。**页中断次数为（1024*1024）**
>
> 方法二中的初始化以列为标准，将每行中的列都访问以便后才访问下一行的内容。由于页内的地址时连续的所以不需要进行页表的查找，直接进行偏移地址递增即可实现。只有访问下一行的时候才会发生页中断**（页中断次数为1024）**
>
> 所以比较两者可知第二种方法实际开销要小很大，运行速度也会快很多，这也体现了为什么应用程序的设计需要和操作系统相匹配的原因。
>
> ![image-20210205152623577](image\image-20210205152623577.png)
>
> ![image-20210205152835458](image\image-20210205152835458.png)
>
> 虚存技术的实现概念：
>
> ![image-20210205155046751](image\image-20210205155046751.png)
>
> 虚存技术的特征：
>
> 1、更大的内存空间：由上图虚拟内存=物理内存+磁盘空间，所以可以位用户提供更大的使用空间。
>
> 2、部分交换：基于分页或分段计算实现内外存交换时不需要将一大块空间进行交换，只需要交换页或段即可。
>
> 3、不连续性：物理内存分配不连续（分页分段特性），虚拟地址空间使用不连续（内外存交换特性导致一个原本在内存忠逻辑上连续的程序，由于一部分页交换到物理磁盘上导致逻辑地址上也不连续）

> 基于页式内存管理的虚存技术实现，即**部分加载**（覆盖技术特点）和**内外存交换**（交换技术特点）实现
>
> ![image-20210205163945286](image\image-20210205163945286.png)
>
> **实现：**在逻辑地址添加标志位，以表明该逻辑地址的状态，类似于上一节提到的页表表项中看到的3个标志位。如下图。其中**修改位**表示该内存中的页内容被修改过，所以需要写回外存中保证内外存数据一致性，若没有被修改则不用进行写回操作。内存中的数据原本就是从外存中读取出来的，若运行期间被修改过当要将其从内存中移除时就需要将其重新写入外存中，保证运行结果是有效的。避免数据丢失。**访问位**表示该页是否被访问，页面置换算法就不会将经常访问的页置换到外存中。
>
> ![image-20210205165101417](image\image-20210205165101417.png)
>
> **实例：**如图蓝色为页表中的表项保存帧号，左边的是对应的虚拟地址范围，帧号为X表示该虚拟地址的驻留位为0即该物理地址不在内存中。
>
> **执行命令：**MOV	REG，	0，将获取虚拟地址0的逻辑地址，则查找页表可知0~4K虚拟地址对应的物理帧号为2，所以物理地址=2*4096+0=8192
>
> **执行命令：**MOV	REG，	32780，将获取虚拟地址32780的逻辑地址，则查找页表可知32780地址对应的页表项为X也就是驻留位为0不存在内存中，此时会产生一个不存在页异常，操作系统根据这个异常信息从外存调取相应数据到内存中，也就完成了一次内外存置换。
>
> ![image-20210205165936197](image\image-20210205165936197.png)
>
> **缺页中断处理如下**
>
> **内存空间足够情况：**
>
> ​	1、将需要访问的页装入内存的物理页中
>
> ​	2、修改页表项，将对应的驻留位修改位1，把物理帧号设置位f
>
> ​	3、重新执行被中断的指令
>
> **内存空间不够情况：**
>
> ​	1、采用页面置换算法选择一个物理页帧f，它所对应的逻辑页位q。如果该页在内存期间被修改过（判断修改位）则需要把他写回外存。
>
> ​	2、把q所在的页表表项中驻留位置0
>
> ​	3、将需要访问的页装入内存的物理页中
>
> ​	4、修改页表项，将对应的驻留位修改位1，把物理帧号设置位f
>
> ​	5、重新执行被中断的指令
>
> ![image-20210205170748788](image\image-20210205170748788.png)

> 后备存储(Backing Store)：处在硬盘中用于保存内存数据的一块区域。
>
> 内存中页在后备存储中的保存形式
>
> ​	1、**简单文件形式保存：**由于外存中数据保存的特点大多是以文件形式，所以内存中应用程序运行时所需的数据信息，如配置参数等，在外存中也可以用文件的形式保存数据。**（应用程序的数据信息）**
>
> ​	2、**二进制文件保存：**用二进制文件来保存内存中的代码数据，以便后续被操作系统读取时可以直接被执行而不用再次编译。**（应用程序的代码信息）**
>
> ​	3、**库文件：**内存中动态加载的共享库程序段将会映射到动态调用的库文件。**（应用程序的依赖库信息）**
>
> ​	4、**交换文件：**应用程序中的**其它信息**会被映射到交换文件中。
>
> ![image-20210205173054659](image\image-20210205173054659.png)
>
> 虚拟内存性能：
>
> 参数p：表示缺页概率
>
> 参数q：表示页是否被修改概率，若页由被修改则需要一次写操作，默认开始也为5ms
>
> ns——>ms，进位为1,000,000
>
> ![image-20210205173447662](image\image-20210205173447662.png)
>
> 从上述公式看，虚拟内存性能效率会远低于实际内存效率。
>
> 但是，如果p缺页几率，若p足够小则虚拟内存的虚拟接近真实内存性能。
>
> 这里缺页率p就可以通过应用程序局部特性实现降低。