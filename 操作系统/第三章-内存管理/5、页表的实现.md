> **页表概述：**页表实际上就是一个大数组
>
> **页表的结构：**索引+表项
>
> 由前面章节可知索引位逻辑地址中的页号，表项位物理地址中的帧号
>
> **帧号的结构：**Flag(标志位)+f(帧号)+o(帧内偏移)
>
> **标志位结构：**标志位占表项中的前3bit，每个标志位都有各自的特殊作用，内容如下
>
> dirty bit：脏位
>
> resident bit：驻留位，表示该地址是否在物理地址中真实存在，0表示不存在，1表示存在
>
> clock/reference bit：
>
> ![image-20210204172911324](image\image-20210204172911324.png)
>
> 
>
> 在操作系统中每个应用程序都有一个页表，其中存储着应用程序中所有数据的逻辑地址映射关系，还有一个页表基址寄存器用来保存该页表的首地址。
>
> ![image-20210204173226582](image\image-20210204173226582.png)
>
> 实际逻辑地址转换物理地址实例，在根据页表查找到对应的帧号时，还会对标志位进行判断，下图中由于(4，0)逻辑地址对应的页表中表项的标志位resident bit为0则表示该逻辑地址没有对应的物理地址。不进行转换，而(3，1023)逻辑地址对应的页表中resident bit为1表示有对应的物理地址，然后根据表项后部分的帧号推出物理地址为(4，1023)
>
> ![image-20210204173430609](image\image-20210204173430609.png)

> 分页方案存在的问题
>
> **分页机制的性能问题：**访问一个内存单元需要2次内存访问
>
> ​	一次用于获取页表项
>
> ​	一次用于访问数据
>
> **页表存储问题：**页表所占用的存储空间可能非常大，如一个64位的计算机，每个页空间位1024Byte，那么一个页表会有多大呢？
>
> 根据页表地址结构可知，1024Byte字节只需要10bit表示，那么剩下的54位都将表示页号，就会有2^54^个页表项，这个数量级太大了
>
> **对于这一类的时间空间问题在计算机中一般有两种方法解决，1、缓存，2、间接访问**

> **转换后备缓存区(Translation Look-aside Buffer，TLB)：用缓存的方式解决访问页表时多次访问内存的问题，进行时间上的优化**
>
> 1、TLB会缓存最近访问的页帧转换表项，保存在CPU的高速缓存区中
>
> 2、访问一个物理地址时，若逻辑地址在TLB中命中，则直接获得物理地址
>
> 3、若无命中TLB，则查找内存中的页表，再把该表项加入TLB中
>
> ![image-20210204184606165](image\image-20210204184606165.png)
>
> **在设计程序时尽量将访问的地址集中在一个局部内，可以减少TLB缺失避免大量的内存访问。**
>
> TLB的建立根据CPU的不同其创建者也不同，可能有CPU自己创建也可能有操作系统创建

> **二级/多级页表：减少页表所占用的空间**
>
> 如一级页表中有一个resident bit位为0的页表项，则对应的二级页表空间就可以直接省略。假设原有1000个页表项，以没100个划分成10个二级页表，则在一级页表中resident bit为0的表项可以不存储二级页表，那么就直接节省了100个页表项的存储空间。
>
> 在二级页表结构中，将原来的逻辑地址中的页号部分在分为两部分，第一个部分记录一级页表的索引，第二个部分记录二级页表的索引。
>
> **在一级页表中保存索引和二级页表首地址，在二级页表中保存索引和帧号。**进行逻辑地址转换时只需要先根据**PTBR寄存器**中保存的**一级页表首地址**和逻辑地址中的**一级索引号**，找到对应的**二级页表首地址**，再根据这个首地址和逻辑地址中的**二级索引号**找到对应的帧号，完成地址转换。
>
> ![image-20210204190237798](image\image-20210204190237798.png)
>
> 由二级页表进行推广，即可得出多级页表的结构
>
> ![image-20210204191205719](image\image-20210204191205719.png)
>
> 实际上多级页表是一种以时间换取空间的做法，减少存储空间的代价就是多次的表查找

> **反向页表（目的：减少页表所占用的空间）**
>
> 在正常的页表结构中，页表总是根据逻辑地址的索引来建立页表，一个64位的系统中常用5级页表的方式存储页表结构，因为64位系统可以发划分的页数量太多，即使以10bit位表示页空间也有2^54^个页存在。
>
> 但是实际上的物理地址是否可以划分这么多的页呢？往往是不能的。正常情况下逻辑地址空间会远大于物理地址空间。所以实际上不需要那么多的页表项来映射物理地址。
>
> 所以可以根据物理地址的帧号建立页表，就称为反向页表
>
> ![image-20210204192628793](image\image-20210204192628793.png)
>
> 反向页表的实现
>
> **页寄存器方案：**使用页寄存器方式建立页表，每个帧对应一个页寄存器，保存对应的逻辑页号。
>
> 使用该页寄存器方式建立的页表增加的开销计算如下，这种方式可以极大的减少页所占用的空间。
>
> 但这种方法的缺点页很明显，无法通过索引直接获取帧号，需要根据页号逐个遍历页表进行查找对应的页号，在获取对应的帧号。**是一种用时间换取空间的方式**
>
> ![image-20210204192908408](image\image-20210204192908408.png)
>
> ![image-20210204193334843](image\image-20210204193334843.png)
>
> ![image-20210204193520907](image\image-20210204193520907.png)
>
> **关联内存方案：**使用TLB中的关联内存方式存储开始实现高速的访问，但由于硬件技术复杂使得该方式建立的页表空间不可能很大，
>
> ![image-20210204194019658](image\image-20210204194019658.png)
>
> ![image-20210204194300980](image\image-20210204194300980.png)
>
> **哈希表查找方案：**（无处不在的哈希表！！）
>
> 页表结构变回了索引+帧号的结构，但与最早的页表结构不同，**这里的页表项的数量依然是以物理帧数为实际最大容量，脱离了逻辑地址的约束**，本质上依然是一个反向页表。
>
> **该页表结构下的逻辑地址转换过程：**获取逻辑地址中的页号，经过哈希函数技术得到索引值，再根据这个索引值和页表首地址找到对应的帧号。即节省了空间，由避免了大量的时间消耗。这里的哈希计算可以通过软件完成，也可以通过硬件方式完成。为了更好的系统运行可以选择硬件方式。
>
> 下图中加入应用程序PID和页号一起进行哈希计算有利于减少哈希冲突。
>
> ![image-20210204194626709](image\image-20210204194626709.png)
>
> ![image-20210204195613763](image\image-20210204195613763.png)