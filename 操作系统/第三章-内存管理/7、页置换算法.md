> # 页置换算法：
>
> **功能：**当发生缺页中断时，内存空间又不足的情况下，决定将哪些页面置换到外存中
>
> **目标：**尽可能的减少页面的换入换出次数
>
> **分析：**为了减少页面的换入换出次数就需要对页进行分析，将一些常用的页保留在内存中，将一些不常用的页置换到外存中去。
>
> **实现：**要判断一个页是否经常被使用，从页本身无法判断，页本身不记录被访问的次数，所以只能通过对应用程序的行为轨迹进行统计和分析才能得出哪些页时经常被访问的。如下图3
>
> **分类：**局部页面置换算法、全局页面置换算法
>
> ![image-20210206125001528](image\image-20210206125001528.png)
>
> ![image-20210206130142673](image\image-20210206130142673.png)
>
> ![image-20210206130940609](image\image-20210206130940609.png)

> ## 局部页面置换算法
>
> #### **最优页面置换算法：**（理想情况下最好的算法）
>
> **目标：**发生缺页中断时，判断内存中的所有逻辑页，找到其中还需等待最长事件才会被访问的页，将其置换到外存。
>
> **实现：**难以实现，实际操作系统中无法找到每一个页要等待多长时间以后才会被访问。
>
> ![image-20210206132034992](image\image-20210206132034992.png)
>
> 举例：如下图所示在1~10时刻每一个时刻都有一个逻辑页被访问，纵坐标page Frames表示内存中存在的页帧号有4个分别为a、b、c、d。从访问路径上看将有5个逻辑页被访问，也就是说下图的时间轴中将会发生页中断，由最优置换算法模拟，判断哪个逻辑页将会被置换到外存中
>
> ![image-20210206132508926](image\image-20210206132508926.png)
>
> 分析：从时间轴可知，在前4个时刻的页访问都不会出现页中断，只有在**第5时刻访问e时才会发生页中断**，那么接下去看**第5时刻以后的访问情况**，分别访问了b、a、b、c、d，可以看出**d页**在后续整个访问的过程中将会等待最长时间才会被访问，所以d页将会被最优置换算法替换到外存中。
>
> ![image-20210206133454620](image\image-20210206133454620.png)
>
> ![image-20210206133500943](image\image-20210206133500943.png)
>
> #### 先进先出算法（FIFO）：
>
> 目标：将内存中驻留时间最长的页置换到外存中
>
> 实现：使用一个链表保存内存中的所有页，所有后加入的页将会以尾插入的方式添加到链表，所以链表首位置的页就是在内存中驻留时间最长的页，每次置换都会将表首的页置换的外存中。
>
> 缺点：被置换的页可能时最经常被访问的页，导致频繁的页交换，性能较低。
>
> ![image-20210206133727126](image\image-20210206133727126.png)
>
> 举例：同样的访问路径，初始链表顺序如图，在FIFO算法下**第5时刻**发生**页中断**将会将链表中首位置的a页置换到外存中，然后在**7时刻**访问a页时又发生**页中断**，将b页置换到外存中，在**8时刻**访问b时又发生**页中断**，将c页置换到外存中，**9时刻**访问c时又发生**页中断**，将d页置换到外存中，**10 时刻**访问d又发生**页中断**，将e置换到外存中。在这一过程中一共发生了**5次页中断**
>
> ![image-20210206134541590](image\image-20210206134541590.png)
>
> ![image-20210206142442219](image\image-20210206142442219.png)
>
> #### 最近最久未使用算法(Least Recently Used，LRU)：
>
> 介绍：与最优页面置换算法近似，最优页面置换算法是**将未来一段时间内**最久不会被使用的页置换，最近最久未使用算法是**将过去一段时间内**最久没被使用的页置换到外存。是一种以过去来推断未来情况作为思想的算法。
>
> 目标：发生页中断时，将最久没有被使用的页置换到外存。
>
> 依据：应用程序设计的局部性特征，使得长时间违背访问的内存不存在与应用程序的局部访问范围内，所以这样一块区域被置换后不会频繁的发生页中断事件。
>
> ![image-20210206143003430](image\image-20210206143003430.png)
>
> 举例：使用LRU算法下列过程中会发生多少次缺页中断。
>
> ![image-20210206143643991](image\image-20210206143643991.png)
>
> 分析：**第5时刻**发生**缺页中断**，根据LRU算法将会把c页置换到外存中，然后在**9时刻**发生**缺页中断**，会将d页置换到外存中，然后在**10时刻**发生**缺页中断**，会将e页置换到外存中去。一共发生3次缺页中断。
>
> ![image-20210206144225994](image\image-20210206144225994.png)
>
> LRU算法需要记录页被访问的事件顺序，有以下两种方法
>
> 1、链表实现：链表首位置是最近被访问的页，链表尾是最久未被访问的页。每次页被访问时在链表中找到对应的链表项，将其移动到链表首，每次发生置换时将链表尾部的页置换出去。（开销在于查找）
>
> 2、设置堆栈：方法如下（开销在于查找和移动）
>
> ![image-20210206144922159](image\image-20210206144922159.png)
>
> 堆栈实现的实例
>
> ![image-20210206145532966](image\image-20210206145532966.png)
>
> 总结：LRU算法对应页的置换效果来说比较好，但是其建立保存页被访问记录的开销较大，不大适合应用在操作系统
>
> #### 时钟页面置换算法(Clock)
>
> 目标：达到LRU算法的效果，又有FIFO算法的简洁
>
> 思路：依然使用LRU算法的思想置换时将最近最久未被使用的页置换，存储页被访问状态时不在使用额外的数据结构，直接在已有的页表中添加标志位，标志该页最近是否被访问。
>
> 思考：如何通过标志位比较得出哪个时最久未被访问？何时应该修改标志位？
>
> 方案：如下
>
> ![image-20210206145744545](image\image-20210206145744545.png)
>
> 注意：上述方案中，被访问页标志位置一的过程有硬件自动完成，不需要软件操作。该算法中用1bit来粗略记录页是否最近被访问，没有LRU算法那么精确
>
> 实现：该时钟结构可以使用循环链表方式实现
>
> ![image-20210206151824821](image\image-20210206151824821.png)
>
> 举例：下列使用Clock算法会有几次页中断
>
> ![image-20210206152522038](image\image-20210206152522038.png)
>
> 分析：a、b、c、d4个物理页在内存中成时钟状，并且指针指向初始a页，在前4个时刻访问后a、b、c、d四个页的访问位分别被置一。
>
> **第5时刻**发生**缺页中断**，开始Clock算法，指针从a开始进行循环查找，由于4个页的访问位都为1所以在第一轮查找中没有页被置换，所有页的访问位都被置为0，指针重新指向a，由于a位的访问位被置为0，所以**a页被置换**e页替换到a页的位置并且访问位**置一**。指针移动到下一格指向b页，6时刻b页被访问，访问位**置一**。
>
> **7时刻**发生**缺页中断**，指针从b位置开始查找访问位为0的页，由于b页访问位为1所以只修改不置换，指针下移所以**c页被置换**a页访问位**置一**。指针指向d页。8时刻访问b页，将其访问位**置一**。
>
> **9时刻**发生**缺页中断**，指针从d页开始查找，由于**d**没有被访问过，所以访问标志位为0，**被替换**c页访问位**置一**。指针指向e。
>
> **10时刻**发生**页中断**，指针从e开始查找，由于e、b、a、c都被访问过，所以第一轮没有页被替换只修改标志位，指针重新指向e，**e**标志位为0**被替换**。
>
> 一共发生**4次缺页中断**。整个过程中指针只在发生置换时进行才移动，指向位置被置换后会移动到下一格。
>
> ![image-20210206154758549](image\image-20210206154758549.png)
>
> 总结：在实际操作系统中大量的页请款下，LRU和Clock产生中断次数是相近的
>
> #### 二级机会算法：
>
> 介绍：在Clock算法中发生页的置换时没有考虑页是否发生过修改，而在之前虚拟内存中有说过要是发生页的置换时，若页被修改过则需要将其写回硬盘中保证数据一致性，所以当Clock选中被修改过页置换到外存中时还需要一次写回硬盘的操作多一次开销，所以这里应该考虑将被修改过的页不优先被选中作为置换页。
>
> 目标：在页置换时考虑访问位和脏位（dirty bit，也就是写位），优先替换只读页。
>
> 实现：在查找要替换页时只将两个位都为0的页替换出去。若有一个位不为0则状态变化如下。
>
> 1、若两位只有一位为1，则将其置置0
>
> 2、若两位都为1，则将访问位置0，保留脏位1，从这也能看出两次机会的特点，被修改过的页一般只有在两次查找后才会被替换出去。（一次页的修改操作会同时将两个标志位都置为1）
>
> ![image-20210206155806311](image\image-20210206155806311.png)
>
> 举例：判断下列过程中发生几次页中断
>
> ![image-20210206163026359](image\image-20210206163026359.png)
>
> 分析：过程和Clock类型，如下图
>
> ![image-20210206163411117](image\image-20210206163411117.png)
>
> 最不常用算法(LFU，least Frequently Used，LFU)
>
> 思路：发生缺页中断时将访问次数最少的页置换
>
> 实现方案：对每一个页使用一个计数器，每当页被访问时增加计数器值
>
> ![image-20210206164124663](image\image-20210206164124663.png)
>
> ![image-20210208133645257](image\image-20210208133645257.png)
>
> 举例：下列过程中使用LFU算法将会发生多少次页中断
>
> ![image-20210208133744531](image\image-20210208133744531.png)
>
> 分析：**5时刻**发生**页中断**，将**d页**置换到外存，**10时刻**发生**页中断**将**e页**置换到外存
>
> 一共发生两次页中断。
>
> 
>
> 以上所介绍的页面置换算法都是正对一个程序使用的，所以叫做局部页面置换算法。

> ## 工作集模型：
>
> 上述所介绍的所有算法都基于一个前提，应用程序的局部性原理，那么要怎么证明一个应用程序的局部性呢？——工作集模型就是一种方法。
>
> ![image-20210208141208448](image\image-20210208141208448.png)
>
> #### 工作集：一个进程当前正在使用的逻辑页面集合（一个时间段内使用的逻辑页面集合）
>
> 二元函数W(t，Δ)：表示从t时刻开始的**之前**一段Δ时间内所有页面组成的集合
>
> ![image-20210208141351807](image\image-20210208141351807.png)
>
> ![image-20210208142027325](image\image-20210208142027325.png)
>
> ![image-20210208142408619](image\image-20210208142408619.png)
>
> #### 常驻集：应用程序在内存中页的集合也就是操作系统给应用程序分配的内存大小和页面置换算法，工作集一般包含所有应用程序的页，所以常驻集一般小于工作集。
>
> ![image-20210208142635388](image\image-20210208142635388.png)

> ## 全局页面置换算法：
>
> **思考：**为什么会需要页置换算法？原因很清楚，就是内存空间不够使用需要将一部分内容放入外存中，而上述所介绍的所有算法中都仅限至于一个程序，**算法中不考虑该应用程序之外的内存空间，只考虑如何选出应用程序使用的内存中被置换代价最小的页**，这就可能导致一个现象，在为一个应用程序分配一定的内存空间后，程序运行了一段时间。这时候内存空间被各种应用程序占满。此时发生页中断后由局部页面置换算法对应用程序的页进行置换，程序正常运行。但是这些内存中的其他程序会有一些空闲的空间可以被腾出来使用，却没有被这样做。**这就是局部页面置换算法的局限性——只能管理一个应用程序的内存空间。**
>
> 可以看到在应用程序内存空间固定在3个时，会不断的发生页中断，进行页面置换，而若是增加一个内存空间给应用程序使用，则只产生一次页中断。但局部页面置换算法无法实现增加物理内存的功能。所以内存管理时还需要使用**全局页面置换算法对内存进行全局的管理，移除应用程序中空间的内存空间，达到更好的内存使用效率。**
>
> ![image-20210208140453434](image\image-20210208140453434.png)
>
> **目标：**全局置换算法的目标在于，根据程序的不同阶段给应用程序动态的分配内存空间大小。
>
> 下面介绍两种全局页面置换算法。
>
> #### 工作集页置换算法
>
> 思想：使用释放应用程序中使用时间较早的内存空间，使其空闲出来给需要的应用程序使用
>
> 原理：给每个应用程序设置固定大小的时间窗口，随着时间的变化将不存在工作集窗口中的逻辑页置换到外存中
>
> 实现方法：设置时间窗口大小，将超过时间窗口的逻辑页置换到外存
>
> 作用：动态释放物理内存空间，使得应用程序在发生缺页时可以增加内存空间为自己使用，在全局上减少所有应用程序发生缺页的次数。
>
> 举例：在下面过程中该应用程序的内存大小变化
>
> ![image-20210208144236900](image\image-20210208144236900.png)
>
> 分析：时间窗口大小为4也就是该窗口包含之前4个时刻内的页，在0时刻工作集中已经有{e、d、a}3个页，在1时刻工作集为{e、d、a、c}，并且有发生页中断。2时刻工作集丢弃-2时刻访问的e变为{d、a、c}3时刻工作集{a、c、d}。依次递推不难得到，工作集在每时刻都发生丢弃和增加的事件。
>
> 而工作集大小的变化则取决于下一时刻访问的页与当前事件窗口下最早的页是否相同，**若相同则工作集不变、若不同则工作集减少或不变（当访问新页时大小不变，当访问已存在页时工作集变小）**
>
> ![image-20210208144700172](image\image-20210208144700172.png)
>
> 总结：工作集页面置换算法会**动态的减少应用程序所占的内存空间**，以增加物理内裤空间。**当有应用程序发生缺页中断时若内存空间中有剩余空间可使用则将其占用**，若没有则使用局部置换算法。**由于时间窗口的限制，应用程序的最大内存空间也被限制，对内存需求大的应用程序不友好。**
>
> 
>
> #### 缺页率页面置换算法：
>
> **思想：**动态调整应用程序所占用的内存空间，为需要内存空间多的应用程序分配更多的内存空间。
>
> **原理：**动态调整应用程序的常驻集大小实现应用程序的内存空间调整。调整常驻集依据的是应用程序的缺页率，给缺页率高的应用程序分配大的常驻集。
>
> ![image-20210208145948198](image\image-20210208145948198.png)
>
> **缺页率：**
>
> ![image-20210208151805603](image\image-20210208151805603.png)
>
> **算法工作过程：**
>
> ![image-20210208151940606](image\image-20210208151940606.png)
>
> **实现过程：**
>
> 发生缺页中断时，计算这次缺页到上一次缺页的时间间隔，与设置的阈值比较，若大于阈值则缩小工作集。若小于阈值则增加工作集。
>
> （时间大表示缺页不频繁，内存足够可以适当减少，将会从工作集中移除这段时间内没有被引用的页）
>
> ![image-20210208152248542](image\image-20210208152248542.png)
>
> **举例：**下面应用程序的工作集大小变化
>
> ![image-20210208152711593](image\image-20210208152711593.png)
>
> **分析：** 应用程序一开始具有3个物理内存页。
>
> 1时刻发生页中断，工作集增加1个，共有4个内存空间，**工作集：{a、c、d、e}**
>
> 4时刻发生页中断，间隔为3，大于阈值2。减小工作集，移除这段时间没有访问的a、e页，增加b页，**工作集为：{c、d、b}**
>
> 6时刻发生页中断，间隔为2，等于阈值2。增加工作集，增加e页，**工作集：{c、d、b、e}**
>
> 9时刻发生页中断，间隔为3，大于阈值2。减小工作集，移除d、b页，增加a页，**工作集：{e、c、a}**
>
> 10时刻发生页中断，间隔为1，小于阈值。增加工作集，增加d页，**工作集：{e、c、a、d}**
>
> ![image-20210208155047896](image\image-20210208155047896.png)
>
> **总结：**缺页率页面置换算法，会动态的增加或减少应用程序的内存空间，没有最大值限制只要物理内存足够大。对大内存应用程序友好。该算法的缺页率体现在阈值的设置上

> ## 抖动问题
>
> 该问题研究在什么样的情况下进程数量可以尽可能多，缺页率又能够接受。
>
> ![image-20210208155543002](image\image-20210208155543002.png)
>
> 在内存中应用程序数量不断增加时，CPU利用率往往入下图，CPU处于大量的页换入换出操作。
>
> （横轴：进程数量，纵轴：cpu利用率）
>
> ![image-20210208160517903](image\image-20210208160517903.png)
>
> 此时需要找到一个平衡点，使得运行即可多的情况下缺页率又能接受。
>
> 那么如何找到这个平衡点就需要MTBF=PFST，平均缺页发生时间等于缺页服务时间，缺页服务时间就是完成一次缺页处理所需要的时间。两者的比值为1是最理想的状态。**两者比值大于1**，则表示内存使用率不高**还可以运行更多程序**，**两者比值小于1**，则表示**内存中应用程序过多**。
>
> 下图中的N-I/O点就是一个最理想的平衡点，在运行程序尽量多的情况下，CPU还有着不错的利用率。
>
> ![image-20210208161505252](image\image-20210208161505252.png)