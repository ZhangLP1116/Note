> 进程的生命期管理
>
> **1、进程的创建（有以下3种引起进程创建的事件）：创建进程时会创建进程的PCB**
>
> ​	系统初始化：操作系统创建init进程，用来管理其他进程的创建
>
> ​	用户请求创建进程：如双击一个可执行程序
>
> ​	正在运行的进程执行了创建进程的系统调用：父进程创建子进程
>
> ![image-20210210164526045](image\image-20210210164526045.png)
>
> **2、进程运行：内核选中一个准备就绪的进程，让它占用CPU进行执行。**
>
> （如何选则就是调度算法的目标）
>
> ![image-20210210163003760](image\image-20210210163003760.png)
>
> **3、进程等待（有以下情况导致进程等待）：由于某些原因进程无法继续执行时，操作系统将进程由运行态切换到等待态，并修改PCB将其放入等待链表。**
>
> ​	请求并等待系统服务，无法马上完成
>
> ​	启动某种操作，无法马上完成
>
> ​	需要的数据没有达到
>
> **（进程的等待是由进程自身发起，只有进程自身知道什么时候无法继续执行）**
>
> ![image-20210210163430510](image\image-20210210163430510.png)
>
> **4、进程唤醒（由以下情况可以使得进程可以被唤醒）：进程重新准备就绪可以被运行**
>
> ​	需要的资源得到满足
>
> ​	得到的事件到达
>
> ​	将进程的PCB加入就绪队列
>
> （进程只能由别的进程或者操作系统唤醒，别的进程是当前正在运行的进程）
>
> ![image-20210210164035833](image\image-20210210164035833.png)
>
> **5、进程结束（有以下情况导致进程结束）**
>
> ​	正常退出
>
> ​	错误退出（进程自身认为无法继续运行，进行退出操作）
>
> ​	致命错误（有操作系统来强制其退出）
>
> ​	被其他进程杀死
>
> ![image-20210210164313429](image\image-20210210164313429.png)

> 进程状态变化模型
>
> 由进程的生命期可以看出进程具有3中状态：就绪态、运行态、等待态
>
> ![image-20210210164747497](image\image-20210210164747497.png)
>
> 进程状态的变迁：
>
> 1、从运行态到阻塞态：进程触发等待事件
>
> 2、从运行态到就绪态：正在运行的进程被其他进程打断，CPU转向执行其他进程
>
> 3、从绪态到运行态：得到CPU是由权
>
> 4、从等待态到就绪态：等待事件完成
>
> ![image-20210210164845463](image\image-20210210164845463.png)
>
> 加入创建和结束态的变迁图
>
> ![image-20210210165212746](image\image-20210210165212746.png)
>
> New——>Ready的过程不会很久，操作系统只需要进行一些初始化操作，如PCB的创建
>
> ![image-20210210165736991](image\image-20210210165736991.png)
>
> Running——>Ready：由操作系统的调度算法完成
>
> ![image-20210210165747700](image\image-20210210165747700.png)
>
> ![image-20210210170127550](image\image-20210210170127550.png)

> 进程挂起模型
>
> 进程挂起：其进程阻塞不同，被挂起的进程将不占用内存空间。
>
> 包含进程挂起的进程状态变迁模型
>
> ![image-20210210170440752](image\image-20210210170440752.png)
>
> 分析：进程挂起模型中，Running、Ready、Blocked、Exit四个状态之间的变迁没有变化
>
> 新增加两个状态：（对应虚拟内存管理时，被存放到外存中的进程）
>
> ​	Ready Suspend：就绪挂起态，可以看作就绪状态的一个拓展，其中存放着已经准备就绪的进程，但是没有足够的内存空间可以使用的时候，进程的状态
>
> ​	Blocked Suspend：阻塞挂起态，内存中由进程要求更多的内存空间时，会将内存中的阻塞态进程移动带外存中，从而使得进程变迁到阻塞挂起态
>
> ![image-20210210171216060](image\image-20210210171216060.png)
>
> 挂起相关的状态变迁
>
> ​	从new——>就绪挂起：当一个进程初始化完毕时，内存又没有足够的空间，就会进入阻塞挂起
>
> ​	从running——>就绪挂起：更高优先级的进程进入就绪挂起态（内存空间不足，外存中有程序要运行）
>
> ​	从就绪到就绪挂起：更高优先级的进程进入就绪挂起态（内存空间不足，外存中有程序要运行）
>
> ​	从阻塞到阻塞挂起：内存中由进程要求更多的内存空间
>
> ​	从阻塞挂起到阻塞：内存空间释放
>
> ​	阻塞挂起到就绪挂起：被挂起的进程等待的事件完成
>
> ![image-20210210172643271](image\image-20210210172643271.png)
>
> ![image-20210210172752575](image\image-20210210172752575.png)

> 进程的调度
>
> 思考：怎么通过PCB和定义的进程状态来管理PCB，帮助完成基础的调度
>
> 分析：
>
> 从整体结构看，操作系统中存在各种各样的进程，这些进程按照循序排列，一次被系统执行。
>
> ![image-20210210173059990](image\image-20210210173059990.png)
>
> 根据进程生命期总结的状态，可以根据状态将进程的PCB划分到不同的队列中实现同一管理
>
> ![image-20210210173111735](image\image-20210210173111735.png)
>
> **就绪队列：**划分时可以根据队列的优先级划分不同的就绪队列，操作系统调度时从优先级高的队列中优先选中进程到CPU中执行，此时被执行的进程PCB修改其中信息为运行状态。
>
> **阻塞队列：**划分时可以根据其等待的事件发划分为不同队列，当一种事件得到满足时，将这一队列中的一个或者多个进程变迁到就绪态，进程的PCB信息从阻塞到变迁。
>
> ![image-20210210173241261](image\image-20210210173241261.png)