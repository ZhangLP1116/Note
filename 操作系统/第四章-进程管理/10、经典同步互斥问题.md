> 1、读者写者问题
>
> ![image-20210225195801849](image\image-20210225195801849.png)
>
> 分析：参考数据库并发控制，写锁无法与写锁、共享锁共存。共享锁可以共存。
>
> ![image-20210225200622465](image\image-20210225200622465.png)
>
> 写操作互斥实现：使用二进制的WriteMutex信号量控制
>
> 对于写者：在写操作之前需要申请WriteMutex信号量，排斥后续的写者或者读者，write为临界区
>
> 对于读者：在读操作之前需要申请WriteMutex信号量，排斥后续写者，read为临界区
>
> ![image-20210225200821366](image\image-20210225200821366.png)
>
> 读操作的共存性实现：**变量Rcount**表示当前正临界区存在的**读者数量**。CountMutex为二进制读者信号量
>
> 对于读者：**第一个进入的读者需要申请WriteMutex信号量，最后一个退出的读者需要释放WriteMutex信号量**。**CountMutex信号量用来确保对Rcount操作的互斥性**，避免两个进程都认为自己时第一个读者。此时的临界区就是对Rcount变量的操作。
>
> ![image-20210225202515579](image\image-20210225202515579.png)
>
> 思考
>
> ![image-20210225202955953](image\image-20210225202955953.png)
>
> 参考读者优先思路，实现写者优先时就需要保存一个写者队列，第一个进入的写者需要申请锁，后续写者进入写者队列等待。当写锁释放后立即交给下一写者。只有当写者队列为空时，读者才能获得锁。
>
> 很明显写者优先使用管程实现比较方便。管程中设置两个条件变量
>
> 初始化：
>
> 定义两个基本读写方法、4个变量、两个条件变量、一个锁。**由锁控制进程是否能进入管程，获得锁的条件由4个变量控制。**okToRead保存等待的读者线程。okToWrite保存等待的写者线程。
>
> ![image-20210225203922731](image\image-20210225203922731.png)
>
> 读者方面实现
>
> Read表示读者会进行的动作，当读者要进行读操作之前需要申请锁获得管程内临界区数据的操作权。
>
> StartRead()是进入管程的申请操作，读者进入管程时需要先申请锁，当管程内没有活动写者或者等待写者时就可以获得锁。同时修改AR变量的值。并释放锁，进入管程进行读操作。
>
> DoneRead()是对退出管程时的收尾操作，退出时**需要修改AR变量的值，所以需要申请锁进行互斥。**若时最后一个读者，则退出时需要判断是否由写者在等待，若有则需要唤醒。
>
> read database时在管程内会执行的动作，在执行该操作时是不带锁的状态，所以可能会有后续的读者或者写者进入管程。
>
> ![image-20210225204900478](image\image-20210225204900478.png)
>
> 写者方面实现
>
> Write表示写者会进行的动作，当写者要进行写操作之前需要申请锁获得管程内临界区数据的操作权。
>
> StartWrite()是进入管程的申请操作，因为需要对**WW、AW变量进行操作所以需要申请锁**，进入前先判断管程内有没有活动的写者或者读者，若由着进入写者等待队列，WW增加，若没有则AW增加，是否锁进入管程内进行写操作。
>
> DoneWrite()是退出管程的收尾操作，退出时需要先判断是否存在等待的写者（写优先）存在则唤醒**（唤醒一个写者）**，若不存在则进一步判断是否存在等待的读者，若存在则唤醒**（唤醒全部读者）**。**修改AW，释放锁退出**。
>
> write database是对管程内会执行的动作，执行该动作是该线程不持有锁，所以可能会有写者或者读者进入管程。
>
> ![image-20210225210739857](image\image-20210225210739857.png)

> 2、哲学家就餐问题
>
> 分析：其中共享数据为5个盘子、一个大小为5的数组表示叉子的状态，1表示叉子空闲。
>
> 由两个动作，拿起叉子和放下叉子，都会导致fork数组值的变化
>
> ![image-20210225211750499](image\image-20210225211750499.png)
>
> 案例一
>
> ![image-20210225212138413](image\image-20210225212138413.png)
>
> 案例二
>
> ![image-20210225212752825](image\image-20210225212752825.png)
>
> 案例三，使用一个二进制信号量实现不同哲学家之间吃饭的互斥性。
>
> ![image-20210225213246093](image\image-20210225213246093.png)
>
> 这里将就餐作为临界区资源，造成了叉子资源的浪费
>
> ![image-20210225213625652](image\image-20210225213625652.png)
>
> 思路
>
> 伪代码
>
> ![image-20210225213827631](image\image-20210225213827631.png)
>
> 程序设计思路
>
> ![image-20210225214024981](image\image-20210225214024981.png)
>
> ![image-20210225214421296](image\image-20210225214421296.png)
>
> 实现
>
> 临界区数据定义，宏定义区域。state数组。两个信号量，mutex互斥信号量，控制临界区内资源操作的互斥性。s[N]同步信号量，控制不同进程之间的同步手段。唤醒等待中的哲学家。
>
> ![image-20210225214557156](image\image-20210225214557156.png)
>
> 整个执行过程，思考、拿叉子准备吃饭、吃饭、放下叉子，其中重要的就是拿起叉子和放下叉子两个方法。**拿起叉子时需要考虑是否由足够的叉子，没有则要阻塞。放下叉子时需要考虑左右是否存在可以唤醒的哲学家。**
>
> ![image-20210225214713934](image\image-20210225214713934.png)
>
> take_forks()实现，由于要设置哲学家的状态，涉及到临界区的访问，所以需要使用mutex信号量进行互斥访问。P、V操作将状态改变语句和测试左右叉子是否能拿起语句包围。
>
> 根据test_take_left_right_forks()的结果若由叉子则进行eat()，若没有则进入阻塞，**P(s[i])将同步信号量减小表示有进程等待**。
>
> ![image-20210225215221385](image\image-20210225215221385.png)
>
> test_take_left_right_forks方法实现，此处设置左右叉子是否能拿起的目的是为了当前哲学家是否能够吃饭。所以需要判断当前哲学家的状态是否饥饿、左右哲学家是否在吃饭。**若判断通过则修改当前哲学家的状态为吃饭。V(s[i])动作增加当前增加的信号量，使得后续的P操作可以通过不会阻塞**。
>
> ![image-20210225220431682](image\image-20210225220431682.png)
>
> put_forks实现，放下叉子需要修改哲学家状态，需要使用mutex进行互斥，同时使用test_take_left_right_forks方法尝试唤醒左右哲学家。**最后没有take_forks动作的P(s[i])操作，其他线程若被阻塞则已经在take_forks动作中经过P(s[i])操作，不需要重复进行。**
>
> ![image-20210225221449176](image\image-20210225221449176.png)
>
> test_take_left_right_forks方法，此处i为当前哲学家的左右哲学家。这里的V(s[i])操作对应的是被阻塞线程take_forks动作中的P(s[i])操作。
>
> ![image-20210225221202213](image\image-20210225221202213.png)
>
> ![image-20210225221332378](image\image-20210225221332378.png)