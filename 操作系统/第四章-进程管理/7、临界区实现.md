> 临界区特征
>
> 互斥：不能又两个进程同时进入临界区
>
> 前进：一个进程申请加入临界区，那么它最终会成功
>
> 有限等待：一个进程它会在一个有限的等待时间内进入临界区
>
> 无忙等待：不要使用死循环的方式等待进入临界区，会带来不必要的CPU浪费。
>
> ![image-20210225153351208](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210225153351208.png)

> 临界区实现
>
> 1、屏蔽硬件中断
>
> 2、基于软件
>
> 3、高级抽象方法

> 屏蔽硬件中断
>
> 由调度原理可知，发生调度的前提就是产生中断。那么只要把中断禁用就不会发生进程切换。就可以实现原子性的操作，如进入临界区。（与计算机原理中保护现场时需要屏蔽硬件中断一样）
>
> ![image-20210225154137028](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210225154137028.png)
>
> 缺点：会影响正常的硬件中断，带来使用问题。且在多CPU系统下需要屏蔽多个CPU中断才能达到目的。

> 软件方案
>
> 基本结构
>
> ![image-20210225155106633](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210225155106633.png)
>
> 方案1
>
> ![image-20210225155512172](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210225155512172.png)
>
> 分析：该方案使用循环的方式每个进程都可以加入临界区，变量turn中保存可以进入临界区的线程号，while（turn!=i）时进入临界区代码，只有要进入临界区的线程号与turn保留值相等，才能进入临界区。执行临界区代码。同时只有在该线程结束后才会修改trun变量使得下一个进程可以进入临界区。
>
> **该方案实现了临界区的互斥性。没有实现前进性。因为该程序没有考虑线程是否想要进入临界区，如线程0进入临界区但该线程不想执行临界区代码，也就不会改变turn的值。那么想要进入临界区的线程1就一直无法进入临界区。**
>
> 
>
> 方案2
>
> ![image-20210225161032082](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210225161032082.png)
>
> 分析：增加了flag变量，表示程序的意愿，但由于使用了多个变量来控制进入临界区，就会产生没有互斥性的问题。
>
> 方案3
>
> ![image-20210225161239344](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210225161239344.png)
>
> 方案4：Peterson算法
>
> ![image-20210225161417110](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210225161417110.png)
>
> 分析：当一个进程要进入临界区时，先将自己对应的标志为置1，然后while循环中判断当前可以进入临界区的线程号turn和该线程对应的flag标志，若当前时j线程可以进入临界区，并且j线程已经准备好进入临界区，则i不能进入临界区。若不满足则i线程进入临界区。
>
> 
>
> 完整代码
>
> ![image-20210225162427977](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210225162427977.png)
>
> 另一种算法
>
> ![image-20210225162829024](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210225162829024.png)
>
> 分析：在进入临界区代码处，增加了等待，当turn为j，并且j已经准备好的情况下，flag先被设置为false，然后等待turn变为i，在将flag设置为true进入临界区。
>
> 
>
> n个进程进入临界区的算法
>
> 方案4进阶
>
> ![image-20210225163104491](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210225163104491.png)
>
> Bakery算法
>
> ![image-20210225163312866](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210225163312866.png)
>
> 
>
> 总结
>
> ![image-20210225163623986](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210225163623986.png)

> 高级抽象方法
>
> 依靠硬件功能和操作系统对其抽象之后的接口来实现进入临界区和退出临界区操作。
>
> ![image-20210225163835501](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210225163835501.png)
>
> 案例1
>
> ![image-20210225164014355](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210225164014355.png)
>
> 分析：使用系统提供的锁结构，便捷的实现临界区的进入和退出。
>
> 如何实现这些抽象结构？
>
> 现有计算机可以提供的一直原子操作
>
> ![image-20210225164216036](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210225164216036.png)
>
> 在test-and-set指令中完成了3个操作，读，判断，写。该指令是一个原子指令。
>
> exchange执行。一条指令即完成两个值的交换。
>
> 两条指令的C语言实现
>
> ![image-20210225164543064](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210225164543064.png)
>
> 可以看到使用机器指令就可以实现原子操作
>
> 基于test-and-set指令的接口实现
>
> ![image-20210225164906675](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210225164906675.png)
>
> 思考
>
> ![image-20210225164958943](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210225164958943.png)
>
> 解决
>
> 进程等待时，将其放入等待队列。临界区进程退出时要做一个唤醒操作。
>
> ![image-20210225165028074](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210225165028074.png)
>
> 基于exchange指令的接口实现
>
> ![image-20210225165440561](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210225165440561.png)
>
> 总结
>
> ![image-20210225165729924](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210225165729924.png)

> 临界区总结
>
> ![image-20210225165910996](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210225165910996.png)