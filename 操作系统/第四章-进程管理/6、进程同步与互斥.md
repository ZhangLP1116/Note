> 简介
>
> ![image-20210217171534608](image\image-20210217171534608.png)
>
> ![image-20210217171746114](image\image-20210217171746114.png)
>
> ![image-20210217171650701](image\image-20210217171650701.png)
>
> 多道程序设计系统的优点
>
> ![image-20210217172044517](image\image-20210217172044517.png)

> 举例：并发操作带来的不确定性问题
>
> 操作系统会为每个进程分配PID，在操作系统创建进程时会有如下操作。
>
> 使用全局变量来控制PID的不重复性
>
> ![image-20210217172253223](image\image-20210217172253223.png)
>
> 在并发操作下两个进程可能因为调度算法导致了PID重复。
>
> 如下，进程1在创建时执行到保存next_pid步骤，这时被高优先级进程创建事件打断。进行上下文切换。此时next_pid没有变化进程一的**PCB保存了next_pid的值**，进程二使用同样的next_pid进行创建，假设PID为100，进程2获得一个PID101，创建结束，进行上下文切换，进程一继续创建，此时**直接读取PCB中的值**并没有重新访问next_pid，导致个进程获得了同一个PID
>
> ![image-20210217173331770](image\image-20210217173331770.png)

> 对并发操作的要求
>
> ![image-20210217173823059](image\image-20210217173823059.png)

> 上述例子中并发进程之间任意位置可能会发生进程切换的情况称为——竞态条件，程序并不是一贯到底的执行，执行过程中的任意位置都可能被打断。这也就导致了并发操作的不可确定性和不可重现性。
>
> ![image-20210225141917305](image\image-20210225141917305.png)
>
> 应对方法，使用原子操作可以一定程度上的解决竞态条件带来的问题。原子操作代表不可在分割的一段操作。该动作执行时不可被打断。
>
> ![image-20210225141934176](image\image-20210225141934176.png)
>
> 几个概念
>
> 临界区：不会被多个进程同时访问的一个区域，由人为规定。互斥就是临界区的特性。
>
> ![image-20210225144059738](image\image-20210225144059738.png)
>
> 案例：
>
> ![image-20210225145616083](image\image-20210225145616083.png)
>
> 分析：由于时间差导致两个人都去买了面包
>
> 解决思路，由于两个之间没有交流导致了上述结果。那么可以使用便签的方式告诉另一个人自己已经取买面包了，从而阻止另一个人再去买一次面包。这里的便签就时操作系统中的锁。
>
> ![image-20210225145705156](image\image-20210225145705156.png)
>
> 锁实现案例1
>
> ![image-20210225145932753](image\image-20210225145932753.png)
>
> 分析：无法完全解决
>
> ![image-20210225150055383](image\image-20210225150055383.png)
>
> 锁实现案例2
>
> ![image-20210225150111699](image\image-20210225150111699.png)
>
> 分析：也无法完全解决
>
> ![image-20210225150135584](image\image-20210225150135584.png)
>
> ![image-20210225150545031](image\image-20210225150545031.png)
>
> 锁实现方案3
>
> ![image-20210225150907922](image\image-20210225150907922.png)
>
> 分析：给一个线程添加等待，若有其他标签不会直接离开，而是等待另一个进程结束。而另一个进程结束只有两种情况，1、买完面包离开，这时候等待进程判断是否有面包发现有，离开。2、进程发现其他标签，于是什么都不做直接离开，等待进程判断有没有面包发现没有则去买面包。
>
> ![image-20210225151320563](image\image-20210225151320563.png)
>
> 临界区解决方案：这里把购买面包的动作设置为临界区，只有一个人完成购买面包的动作之后其他人才能执行这个动作。
>
> ![image-20210225151920804](image\image-20210225151920804.png)
>
> 实现：每个进程要执行购买面包时先要请求锁，获得购买面包的权力，在购买完面包后在释放锁，使得别人能够获得购买面包的权力。**该方案的特点时只有一个锁**，避免了方案二中多个锁导致没人购买的问题。
>
> ![image-20210225152006838](image\image-20210225152006838.png)
>
> 总结：临界区很好的解决了不确定性问题。但是不确定性问题从功能代码转移到了临界区代码上。由于进入临界区也是有一系列代码组成，那么在进入临界区时就有可能出现同时又两个程序进入了临界区。所以后面要讨论的就是如何进入临界区的问题 。

