> 进程间通信
>
> ![image-20210226170419714](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226170419714.png)

> 为什么需要进程间通信？
>
> 不同进程间需要协作完成一个任务，所以在保持进程相互独立的前提下，需要一些进程间互相通信的手段。即IPC机制。

> **IPC机制**
>
> 进程间通信的基础动作就是，发送和接受（send和receive），在发送之前进程间需要建立通信的通道。
>
> 通道的实现有多种方式如物理内存，硬件总线，逻辑属性等。根据实现方式的不同其名称也不同。
>
> ![image-20210226170758121](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226170758121.png)
>
> **消息模型**
>
> 通信的方式大概有两种，a图通过第三者传递消息属于间接通信。b图通过一个共享内存传递消息属于直接通信。
>
> ![image-20210226171121467](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226171121467.png)
>
> **直接通信**实现要求：要有明确的接收者和发送者，两者之间不存在多个链路
>
> ![image-20210226171242917](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226171242917.png)
>
> **间接通信**实现要求：不需要确定接受者和发送者。发送者只需要发送数据不需要知道是谁接受的，接收者也不需要知道是谁发送的。往往通过内核中的一个共享空间实现。
>
> ![image-20210226171518523](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226171518523.png)
>
> ![image-20210226171914630](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226171914630.png)
>
> 
>
> 另一种通信分类方式：**阻塞与非阻塞**
>
> 阻塞型表示发送消息时必须确保消息发送完毕才会去干其他事
>
> 非阻塞型表示完成消息发送动作后直接做其他事，无论消息是否发送成功。
>
> 消息发送动作完成和消息发送成功之间存在一个时间差是否关注这个时间差就是阻塞和非阻塞之间的区别
>
> ![image-20210226172016979](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226172016979.png)
>
> **通信链路缓冲**
>
> 根据消息队列的容量，发送方和接收方之间存在3中情况
>
> ![image-20210226172542913](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226172542913.png)

> 信号：类似硬件中断的方式由操作系统告诉相应软件有某个消息进来需要处理。
>
> ![image-20210226173409770](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226173409770.png)
>
> 软件接受到信号后有几种处理方式
>
> 1、调用信号对于的处理函数
>
> 2、不理睬，有操作系统默认处理
>
> 3、mask，不处理
>
> 信号通信的缺点
>
> 无法传送数据，只能知道有人想要联系
>
> 
>
> 信号通信的实现
>
> 1、应用程序向操作系统注册自己需要处理的信号的函数入口地址（句柄）
>
> 2、操作系统收到中断后，将原来要执行的下一条指令地址压入对应的应用程序堆栈，将指令指针寄存器修改为对应服务函数的入口地址。
>
> 3、CPU跳到对应的服务程序进行处理
>
> ![image-20210226174030535](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226174030535.png)

> 管道：可以进行数据交换，用于早期应用程序不同模块之间的信息交换，以完成一个大功能。
>
> 原理：将一个进程的输出重定向到另一个程序的输入，以完成一个流水线式的工作模式
>
> 实例：如类linux系统中的组合命令之间的竖线，竖线就表示一个管道。前一个命令的输出会变成另一个命令的输入。如下命令可以完成一个分页显示目录信息的效果。
>
> ![image-20210226175457460](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226175457460.png)
>
> 实现
>
> linux内核shell接受到这个组合命令时，shell就会通过管道形式去实现。shell会创建两个进程ls和more，还有一个管道（一块共享内存或者文件）。父进程shell将ls进程的输出设置为管道，将more进程的输入设置为管道。然后顺序执行ls进程和more进程。
>
> 两个进程不关心自己的输入输出目的地
>
> ![image-20210226175537614](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226175537614.png)
>
> 完整过程
>
> ![image-20210226180232497](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226180232497.png)

> 消息队列：也是一种数据传输方式，可以实现不相关进程间的特性。
>
> 与管道的区别：管道需要有父进程协调才能实现数据通信。而且管道的数据保存形式是字节流方式接收方需要解析。没有具体的数据结构。**消息队列可以克服这两种情况**。
>
> ![image-20210226180531635](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226180531635.png)

> 共享内存：不同于前三种间接通信方式，共享内存是直接通信
>
> 前3中通信方式都需要系统调用去完成send和receive操作。共享内存可以直接有应用程序来完成这两个操作。需要同步互斥机制协调。
>
> 原理：两个进程访问不同虚地址空间实际上是访问同一个物理内存空间，以实现共享内存
>
> ![image-20210226181418819](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226181418819.png)

> 网络进程通信机制：socket