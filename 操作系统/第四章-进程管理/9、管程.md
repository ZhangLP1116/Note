> 管程：是操作系统提供的一种比信号量更加抽象的线程同步互斥手段，不同于一开始就为操作系统设计的信号量，管程最早是用在高级程序语言中。
>
> ![image-20210225184920598](image\image-20210225184920598.png)
>
> 管程：包含临界区和同步互斥。使用**锁作为入口实现互斥**。使用**条件变量作为同步手段**。获得锁进入管程后即为临界区操作，同样临界区操作完成后需要释放锁。退出管程。管程中的临界区可以有共享数据，一系列动作，初始化代码。
>
> 过程中每个条件变量都有wait和signal操作。前者表示需要等待条件满足，使得**线程释放锁进入等待队列**。后者表示某个条件已经得到满足，使等待队列中的线程获得锁继续执行。以**达到同步效果**。
>
> 管程中可以设置多个条件变量表示不同的等待条件。
>
> ![image-20210225185550438](image\image-20210225185550438.png)
>
> ![image-20210225185706057](image\image-20210225185706057.png)
>
> 条件变量动作实现
>
> ![image-20210225191054503](image\image-20210225191054503.png)
>
> 使用管程解决生产者消费者问题
>
> 初始化：定义一个锁，一个count用来记录buffer中的数量，两个条件变量notFull、notEmpty，生产者消费者对应动作和count变量操作视为临界区。
>
> ![image-20210225191739255](image\image-20210225191739255.png)
>
> 加入互斥
>
> 根据管程的结构可知，管程的互斥性是在进入管程开始即执行的，所以在代码块的最开始。
>
> ![image-20210225191925097](image\image-20210225191925097.png)
>
> 同步实现
>
> 若buffer满，则生产者在增加物品之前进入等待。消费者在取出物品后唤醒。notFull保存条件变量保存等待的生产者线程
>
> ![image-20210225192446183](image\image-20210225192446183.png)
>
> 若buffer空，则消费者在取出物品前进入等待。在生产者放入物品后被唤醒。notEmpty条件变量存放等待的消费者线程。
>
> ![image-20210225193400032](image\image-20210225193400032.png)
>
> 
>
> 但条件变量被唤醒后，管程内同时存在两个线程在执行，这个时候该先执行哪个线程？
>
> 方法一：左边，执行唤醒操作的线程全部执行完毕后在执行被唤醒的进程。
>
> 方法二：右边，执行唤醒操作的线程在执行唤醒动作后直接切换到被唤醒的进程执行，当被唤醒的进程执行完毕后在切换回唤醒进程执行。
>
> ![image-20210225193701671](image\image-20210225193701671.png)
>
> 两种实现方式对程序的影响。
>
> **Hansen方法**在执行唤醒操作后并没有直接切换到被唤醒的程序，也就导致接下来的过程中可能有其他程序被唤醒，所以在切换回去时需要进一步判断条件是否满足。
>
> **Hoare方法**在执行唤醒操作后直接切换到被唤醒程序，不存在条件的变化，所以在被唤醒程序中不需要再次进行判断，使用if语句就足够。
>
> ![image-20210225194446032](image\image-20210225194446032.png)
>
> ![image-20210225194840289](image\image-20210225194840289.png)

> 加入管程后的同步互斥实现图
>
> ![image-20210225195335743](image\image-20210225195335743.png)
>
> 总结
>
> ![image-20210225195413579](image\image-20210225195413579.png)