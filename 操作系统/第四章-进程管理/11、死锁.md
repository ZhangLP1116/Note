> 死锁
>
> ![image-20210226132335729](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226132335729.png)
>
> 现实案例
>
> ![image-20210226132423283](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226132423283.png)
>
> 系统案例
>
> ![image-20210226132609597](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226132609597.png)

> 死锁的产生：由于进程的并发执行导致

> 系统模型：用来更好的分析死锁问题
>
> 资源：在操作系统中存在各种资源，CPU资源、内存资源、I/O资源
>
> 资源个数：每个类型的资源都有对应的实例个数
>
> 进程：进程对资源有请求/获取、使用/持有、释放几个动作
>
> ![image-20210226132938899](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226132938899.png)
>
> 将进程和资源抽象后形成两个集合：P、R。P是系统中所有进程的集合，R是系统中所有资源的集合
>
> 将进程和资源之间的动作抽象后，**进程请求资源用P——>R的有向边表示**，**资源被进程持有用R——>P的有向边表示**。
>
> ![image-20210226134907684](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226134907684.png)
>
> 将进程用圆点表示、将资源用正方形表示，正方形中的小正方形是这个资源可分配的实例个数
>
> ![image-20210226135404661](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226135404661.png)
>
> 经过上述抽象后就可以将资源进程关系构造成一个“图结构模型”
>
> ![image-20210226135625701](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226135625701.png)
>
> 分析上图可知，P1、P2都持有一部分资源，但是还需要请求一部分资源。P3持有持有资源但是没有在申请资源。重要P3释放资源后P2就能得到满足。同理P2释放资源后P1就能得到满足，所有没有死锁发生。
>
> ![image-20210226140228289](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226140228289.png)
>
> 分析上图由于P3还需要请求R2，但是R2已经分配给P1、P2所有P3需要等待P1、P2，同时P1、P2又要等待P3，生成死锁。
>
> 比较两个图可以看出，存在死锁的图具有全连通性
>
> ![image-20210226140958993](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226140958993.png)

> 死锁出现——>会产生以下4中情况
>
> 同时发生以下4种情况不一定会导致死锁
>
> ![image-20210226141232619](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226141232619.png)

> 操作系统对于死锁的要求
>
> 有以下3中。第一种策略可实现，但是代价大。第二种策略需要检测死锁开销较大。常用第三种策略
>
> ![image-20210226142251437](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226142251437.png)
>
> 死锁预防：从根本上解决死锁。
>
> 思路：可以从死锁发生条件上解决有以下4中方式
>
> ![image-20210226143924068](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226143924068.png)
>
> 
>
> 死锁避免：要求系统处于安全状态，避免死锁发生的可能
>
> ![image-20210226144348063](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226144348063.png)
>
> 死锁避免要求系统处于安全状态，不安全状态不等于死锁状态，但包含死锁。所有可以避免死锁的产生，同理会造成资源利用率不足的现象。
>
> 寻找安全状态的关键在于找到一个安全的序列，重要按照这个序列执行进程据不会发生死锁。
>
> ![image-20210226144808274](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226144808274.png)
>
> ![image-20210226145429242](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226145429242.png)
>
> ![image-20210226151053152](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226151053152.png)
>
> 银行家算法：
>
> ![image-20210226151403551](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226151403551.png)
>
> ![image-20210226151458891](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226151458891.png)
>
> 算法数据结构
>
> Max矩阵：每一行是一个进程，行中每一列是该进程最多可以申请这种类型资源的数量
>
> Available数组：表示实际每种资源当前可分配数量
>
> Allocation矩阵：表示每个进程的对应类型资源以获得数量
>
> Need矩阵：表示每个进程对应类型的资源可能还需要获取的个数
>
> ![image-20210226152037121](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226152037121.png)
>
> 3个矩阵之间的关系
>
> ![image-20210226152625159](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226152625159.png)
>
> 安全状态判断算法
>
> 设置两个数组Work和Finish。Finish中保存安全序列，每个元素是表示一个进程是否能正常结束。work数组模拟Available数组。
>
> 1、初始化：Work数组赋值Available数组值。Finish数组假设所有进程都每结束，设置为false
>
> 2、判断进程是否能够正常完成，依据是比较进程后续可能需要的资源可work还可以获得的资源比较若足够则可以完成
>
> 3、若该进程可以完成，则将该进程的持有的资源增加work中，因为经常结束后其拥有的资源都会被释放，可以作为下一个进程的资源。再将Finish数组中对应进程设置为true
>
> 4、判断Finish中的每一个进程，若都为True则系统是安全的，否则系统就是不安全的
>
> ![image-20210226153238378](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226153238378.png)
>
> 银行家算法实现
>
> 当一个进程请求资源是需要经过以下几个步骤
>
> 1、判断请求的资源个数是否超过可获得的最大个数
>
> 2、判断可获得资源个数是否满足请求资源的个数
>
> 3、满足以上条件后修改矩阵和数组的值，进行安全状态判断算法计算。若算法得出结果为safe则将资源分配给进程，若结果为unsafe则使进程等待，恢复矩阵和数组的值。
>
> ![image-20210226155405291](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226155405291.png)
>
> 案例1：分析下面系统状态是否为安全状态
>
> ![image-20210226155847407](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226155847407.png)
>
> 分析：初始化work：[0,1,1]，Finish：[0,0,0,0]
>
> 1、找到一个Need资源小于work的进程，P2满足，所以Finish：[0,1,0,0]，修改work为[6,2,3]
>
> ![image-20210226160722974](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226160722974.png)
>
> 2、继续寻找满足Need的进程，都满足，假设选中P1，Finish：[1,1,0,0]，修改work为[7,2,3]
>
> ![image-20210226161047630](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226161047630.png)
>
> 以此类推，P3、P3也可以被满足，所以Finish：[1,1,1,1]，所以系统是安全的，安全序列为[P2,P1,P3,P4]
>
> 案例二，初始状态，P1发生资源请求[1,0,1]，是否能通过银行家算法？
>
> ![image-20210226162518466](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226162518466.png)
>
> 分析，假设分配给P1资源后，系统的状态如下，初始化work：[0,1,1]，Finish：[0,0,0,0]，进行安全状态判断算法
>
> ![image-20210226162316357](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226162316357.png)
>
> 1、寻找能够满足的Need，不存在，系统不安全，拒绝给P1分配资源
>
> 
>
> 死锁检测
>
> ![image-20210226163025029](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226163025029.png)
>
> 检测方法一
>
> 根据资源进程图结构，将图中的资源节点去除，留下进程节点，判断进程节点是否存在环，若存在则可能死锁。
>
> ![image-20210226163153932](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226163153932.png)
>
> 检测方法二，与安全状态检测算法很类似
>
> 数据结构
>
> ![image-20210226163533157](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226163533157.png)
>
> 算法流程
>
> ![image-20210226163724019](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226163724019.png)
>
> 分析，死锁检测算法与安全状态算法的区别是，安全状态算法是进程发起请求后，检测系统是否安全是否同一请求。死锁检测算法是在进程发起请求后，定期检测系统中所有等待的请求，判断请求队列中的进程是否能够被满足，若有一个不能则发生了死锁。
>
> 算法复杂度：开销较大
>
> ![image-20210226164335341](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226164335341.png)
>
> 案例1：判断系统中是否存在死锁
>
> ![image-20210226164658483](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226164658483.png)
>
> 分析：系统中一共有3中资源，资源的可分配个数Available：[0,0,0]，所有work：[0,0,0]，Finish：[0,0,0,0,0]
>
> 1、进程中P0、P2没有继续请求资源可以正常结束Finish：[1,0,1,0,0]，work：[3,1,3]
>
> 2、work可以满足任意进程请求，假设满足P1，则Finish：[1,1,1,0,0]，work：[5,1,3]
>
> 以此类推所有请求都可以被满足，系统中没有死锁
>
> ![image-20210226165319327](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226165319327.png)
>
> 案例2：判断系统中是否存在死锁
>
> ![image-20210226165356218](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226165356218.png)
>
> 分析：Available：[0,0,0]，所有work：[0,0,0]，Finish：[0,0,0,0,0]
>
> 1、进程P0可以直接结束，work：[0,1,0]，Finish：[1,0,0,0,0]
>
> 2、无法满足如何请求，Finish：[1,0,0,0,0]，系统存在死锁
>
> ![image-20210226165649769](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226165649769.png)
>
> 检测算法需要考虑的问题
>
> ![image-20210226165838406](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226165838406.png)
>
> **在银行家算法和死锁检测算法中都需要一个变量max表示进程可能需要的最大资源，而这个资源往往是进程自身不能够确定的，所有这两个算法在实际系统中很少使用**
>
> 
>
> 死锁恢复（实际系统中常用的方法）：发生死锁后如何恢复
>
> ![image-20210226165920955](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226165920955.png)
>
> 杀死进程的原则
>
> ![image-20210226170142788](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20210226170142788.png)