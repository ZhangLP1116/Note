> 线程介绍
>
> ![image-20210211143714873](image\image-20210211143714873.png)

> 线程的由来
>
> 实例：
>
> ![image-20210211144046220](image\image-20210211144046220.png)
>
> 分析：单进程设计时，所以功能模块在一个程序文件中顺序排列，运行该进程时CPU执行播放任务时可能会由于Read()对硬盘的读写而使得声音断断续续。
>
> 整个程序在操作系统中是以一个进程的形式存在，无法实现各各模块之间的并发。
>
> ![image-20210211144200859](image\image-20210211144200859.png)
>
> 多进程程序实现
>
> ![image-20210211144700719](image\image-20210211144700719.png)
>
> 分析：将该程序不同功能模块分开多个独立文件存放，使得程序运行时在系统中一多个进程的形式存在，可以实现进程间的并发存在，如读取任务等待时，CPU可以执行解压任务将以读取出的音频文件进行解压。而单进程实现下无法实现这一特点。
>
> 
>
> 多进程程序设计需要考虑的问题
>
> 1、不同进程间如何通信？
>
> ​	如上述单进程时各各功能模块顺序执行，当执行播放时读取和解压操作肯定执行完毕，但是在多进程中各各功能模块互相独立，即使读取任务完成了播放进程也无法直接读取其信息。也无法直接判断读取任务是否完成。
>
> 2、系统开销问题？
>
> ​	多进程设计意味着操作系统要创建额外的PCB进行进程管理，切换进程时的开销，如何将这些开销达到最小？
>
> 
>
> 根据上述问题分析
>
> ​	由于操作系统设计的安全性原则要求不同进程之间互相隔离，不允许进程访问其他进程的内存空间。所以为了解决多进程程序设计问题，**就需要使得有另一种实体**，这个实体有进程的特性可以**在CPU层面上并发执行**，**在操作系统层面上多个实体可以属于同一进程共享地址空间实现数据共享**。
>
> 这个实体就是——线程，所以线程可以看作是对原有进程的一个细化分解，是保留CPU层面上的进程概念并重命名为线程，对操作系统层面的进程进行重新定义其内容。
>
> ![image-20210211150124989](image\image-20210211150124989.png)
>
> 

> 什么是线程
>
> 线程的定义：是进程中的一个执行流程。可以看作是之前的进程定义，是一段功能的执行过程。
>
> 进程的定义：因为线程的出现取代了原有进程的含义，所以进程也被重新定义。
>
> ​	从资源角度：进程是一个资源平台，把各种资源组合起来供其中的线程使用，如地址空间资源，打开文件资源等
>
> ​	从运行角度：是线程在资源平台上的一个执行流程
>
> ![image-20210211151127280](image\image-20210211151127280.png)
>
> ![image-20210211152453979](image\image-20210211152453979.png)
>
> 既然出现了线程操作系统就要对其进行管理，也就使用了——TCB线程控制器，其中PC表示程序计数器、SP表示堆栈、寄存器
>
> ![image-20210211151807034](image\image-20210211151807034.png)
>
> 线程的使用性：在强调性能的程序中使用多线程设计程序。在强调安全稳定性的程序中使用进程也就是单个线程方式设计程序。
>
> ![image-20210211152336135](image\image-20210211152336135.png)

> 进程与线程之间的比较
>
> 1、进程创建时间比线程大，进程是操作系统控制的单位，创建进程时要为进程分配地址空间，创建PCB、页表等必要初始化，而线程创建不用，它共享进程的地址空间，初始化步骤少。
>
> 2、同理线程终止时需要处理的步骤也比进程少
>
> 3、进程切换大于线程切换时间。
>
> ​	（一）根据内存管理可知操作系统为配个进程分配页表用来保存逻辑地址和物理地址的映射，进程的切换也就需要对页表进行切换
>
> ​	（二）根据内存管理可知操作系统在内存调度时是以进程为单位，进行进程切换时若进程在外存中挂起则还需要从外存中读取，费时间。而线程之间切换由于在同一进程下所以无序考虑是否在外存。
>
> 4、线程之间共享资源，可以直接进行不通过内核的通信，速度快。而进程之间的通信就需要使用操作系统提供的空间，需要进行内核态的转换，速度较慢。
>
> ![image-20210211152722657](image\image-20210211152722657.png)

> 线程实现
>
> ![image-20210217123158452](image\image-20210217123158452.png)
>
> 用户线程：在用户空间实现，操作系统无法控制，由应用程序控制（线程库创建与销毁）
>
> 内核线程：在内核中实现，由操作系统控制
>
> 
>
> 用户线程与内核线程的对应关系
>
> ![image-20210217123456137](image\image-20210217123456137.png)
>
> ![image-20210217123517209](image\image-20210217123517209.png)
>
> ![image-20210217123522954](image\image-20210217123522954.png)
>
> 用户线程的实现
>
> 从上述线程与进程概念可知，线程是进程的一个过程，进程是线程的资源平台，在用户空间操作系统只负责创建进程，进程中的线程由应用程序自身创建，操作系统**不对其线程**进行管理。只**对应用程序的进程**进行管理。（操作系统只提供资源平台的管理）
>
> ![image-20210217123555845](image\image-20210217123555845.png)
>
> ![image-20210217123921786](image\image-20210217123921786.png)
>
> 用户线程的缺点：根据用户线程的特点即可总结出如下几个缺点
>
> 1、由于线程是应用程序管理，操作系统层面只能看到一个进程，所以在操作系统进行进程管理时，是无法为其内部的各各线程分配CPU时间，也就**导致了一个进程内的所有线程只享受一个CPU时间**，所以该进程内的线程可用CPU时间比单线程进程要少。
>
> 2、在操作系统层面只能看到一个进程，也导致了若该进程中由一个线程提交了阻塞性系统调用（读取文件等）操作系统就会将整个进程转换为等待态。**无法**像其他线程那样**灵活的调度**。
>
> 3、线程饿死，当用户进程分配到CPU使用权后，就有应用程序来决定由哪个线程使用，而线程使用时除非它主动交出CPU使用权，否则进程内的其他线程就一直无法使用CPU。
>
> ![image-20210217124705170](image\image-20210217124705170.png)
>
> 
>
> 内核线程的实现
>
> 与用户线程不同的时，内核线程的TCB保存在内核空间中，由操作系统直接管理线程，所以这种操作系统的管理粒度从进程变为线程。（如windows）
>
> 优点：由操作系统直接管理线程，使得程序运行更加高效
>
> 缺点：操作系统需要额外的线程管理开销
>
> ![image-20210217125411195](image\image-20210217125411195.png)
>
> ![image-20210217125622367](image\image-20210217125622367.png)
>
> 
>
> 轻量级进程
>
> ![image-20210217130032655](image\image-20210217130032655.png)