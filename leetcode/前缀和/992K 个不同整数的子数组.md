> #### [992. K 个不同整数的子数组](https://leetcode-cn.com/problems/subarrays-with-k-different-integers/)
>
> 难度困难295收藏分享切换为英文接收动态反馈
>
> 给定一个正整数数组 `A`，如果 `A` 的某个子数组中不同整数的个数恰好为 `K`，则称 `A` 的这个连续、不一定不同的子数组为*好子数组*。
>
> （例如，`[1,2,3,1,2]` 中有 `3` 个不同的整数：`1`，`2`，以及 `3`。）
>
> 返回 `A` 中*好子数组*的数目。
>
>  
>
> **示例 1：**
>
> ```
> 输入：A = [1,2,1,2,3], K = 2
> 输出：7
> 解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].
> ```
>
> **示例 2：**
>
> ```
> 输入：A = [1,2,1,3,4], K = 3
> 输出：3
> 解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].
> ```
>
>  
>
> **提示：**
>
> 1. `1 <= A.length <= 20000`
> 2. `1 <= A[i] <= A.length`
> 3. `1 <= K <= A.length`
>
> 通过次数21,508
>
> 提交次数47,854

> 解法，前缀和，时间复杂度O(N)，空间复杂度O(ASize)
>
> 思路1、对于固定范围内符合条件的子数组可以：用最大范围-最大不允许范围=结果，即atMostK(K)-atMostK(K-1);（与795题相似）
>
> 思路2、前缀和是相对于连续数组中第一个元素进行计算的，即一般式为：
>
> pre=0（初值）；pre=pre-start+1；sum+=pre（一般式在滑动窗口场景经常应用）
>
> 当初始位置为0时可以写成：pre++；sum+=pre
>
> ```c
> int subarraysWithKDistinct(int* A, int ASize, int K){
>     if(K==1) return atMostK(A,ASize,K);
>     return atMostK(A,ASize,K)-atMostK(A,ASize,K-1);
> }
> 
> int atMostK(int* A, int ASize, int K){
>     int pre=0,nums[ASize+1];
>     int res=0;
>     memset(nums,0,sizeof(int)*(ASize+1));
>     for(int i=0;i<ASize;i++){
>         if(nums[A[i]]==0) K--;
>         while(K<0){
>             nums[A[pre]]--;
>             if(nums[A[pre]]==0) K++;
>             pre++;
>         }
>         nums[A[i]]++;
>         res+=i-pre+1;		// 每次循环都要进行前缀和计算，前缀和初始位置i只有在数组内的数字种类发生更替时才会变化，
>         					// 每次变化后只需要计算相对于这个连续子串开始位置新增加数组，对于重叠部分无需重复计算
>         					// 新增加数组=结束位置-开始位置，只适用于要求子数组连续的场景（新加数组=新元素和前面每一个元素的组合+自身）
>         					// [1,2,3]中增加4，[1,2,3,4]中的新数组为：[3,4]、[2,3,4]、[1,2,3,4]、[4]
>     }
>     return res;
> }
> ```
>
> 