> #### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)
>
> 难度中等5362收藏分享切换为英文接收动态反馈
>
> 给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。
>
>  
>
> **示例 1:**
>
> ```
> 输入: s = "abcabcbb"
> 输出: 3 
> 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
> ```
>
> **示例 2:**
>
> ```
> 输入: s = "bbbbb"
> 输出: 1
> 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
> ```
>
> **示例 3:**
>
> ```
> 输入: s = "pwwkew"
> 输出: 3
> 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
>      请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
> ```
>
> **示例 4:**
>
> ```
> 输入: s = ""
> 输出: 0
> ```
>
>  
>
> **提示：**
>
> - `0 <= s.length <= 5 * 104`
> - `s` 由英文字母、数字、符号和空格组成

> 解法：滑动窗口，时间复杂度O(N)，空间复杂度O(1)
>
> 哈希表记录子串中出现过的字符，每遇到一个重复字符后将前指针pre不断后移，直到发现重复的字符的位置，这个位置的后一个既是下一个子串的开始。
>
> pre指针后移过程中不断将路程上的字母从哈希表中去除。这些字符不被算在新子串中。
>
> ```c
> int lengthOfLongestSubstring(char * s){
>     int res=0,len=0,pre=0;
>     int *hash=(int*)calloc(128,sizeof(int));
>     for(int i=0;s[i]!='\0';i++){
>         if(hash[s[i]]==0){
>             len++;
>             hash[s[i]]++;
>         }
>         else{
>             if(len>res) res=len;
>             while(1){				// pre指针后移，直到找到重复字符
>                 if(s[pre]==s[i]){
>                     len=i-pre;
>                     pre++;
>                     break;
>                 }
>                 hash[s[pre]]=0;
>                 pre++;
>             }
>         }
>     }
>     if(len>res) res=len;
>     return res;
> }
> ```

> 解法二：滑动窗口优化
>
> 上一个方法中hash只用来记录是否子串中是否已经存在该字符，每次取下一个字符开始位置时需要逐个遍历找到重复字符的位置，在这一步可以进行优化。
>
> 充分利用哈希表：**使用哈希表记录每次出现字符在原数组中的位置**。只有在找重复字符时可以直接定位不需要逐个遍历。
>
> 发现重复字符：使用哈希表记录字符下标后，判断字符是否重复只需要判断新字符的位置相对于pre指针的位置。
>
> **当前字符记录在pre指针之前，即不是重复字符**
>
> **当前字符记录在pre指针之后，即为重复字符**
>
> ```c
> int lengthOfLongestSubstring(char * s){
>     int res=0,i,pre=0;
>     int hash[128];
>     memset(hash,-1,sizeof(int)*128);		// 默认每个字符初始位置-1，都在pre之前
>     for(i=0;s[i]!='\0';i++){
>         if(hash[s[i]]>=pre){			// 每次判断字符位置，若在pre指针后（包含pre位置）则重复出现，进行长度结算，移动pre到下一个串的开始
>             if(i-pre>res) res=i-pre;
>             pre=hash[s[i]]+1;
>             hash[s[i]]=i;
>         }
>         hash[s[i]]=i;		// 每次都要更新哈希表中字符的位置
>     }
>     if(i-pre>res) res=i-pre;
>     return res;
> }
> ```
>
> ![image-20210423145853501](image\image-20210423145853501.png)