> #### [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)
>
> 难度简单974收藏分享切换为英文接收动态反馈
>
> 给定一个大小为 *n* 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。
>
> 你可以假设数组是非空的，并且给定的数组总是存在多数元素。
>
>  
>
> **示例 1：**
>
> ```
> 输入：[3,2,3]
> 输出：3
> ```
>
> **示例 2：**
>
> ```
> 输入：[2,2,1,1,1,2,2]
> 输出：2
> ```
>
>  
>
> **进阶：**
>
> - 尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。
>
> 通过次数309,170
>
> 提交次数468,686

> 解法：摩尔投票，时间复杂度O(n)，空间复杂度O(1)
>
> 摩尔投票法：最初假设的使用场景是在**选举中找出持有票数超过半数的选举人**。
>
> 基本过程：
>
> 抵消阶段
>
> ​	1、先拿到一张选票，与下一张选票进行比较，若相同则选票计数增加，若不同则选票计数减少，
>
> ​	2、若选票为0则下一张选票作为基准继续进行上述过程，最终得到一个获选票
>
> 计数阶段（可能不存在持有超过半数选票的选举人，被找出的候选人仅仅是其他选票被抵消后的幸存者，所以需要对其持有票数进行判断）
>
> ​	3、最后在进行一次候选票的数量统计，判断该选票是否超过半数，若超过则找到，若不超过则这次选举中不存在持有超过半数选票的选举人。
>
> **整个摩尔投票法需要对数组进行两次的遍历，第一次用于抵消阶段，第二次用于计数阶段**
>
> 原理：若存在持有超过半数选票的选举人则其选票被其他所有选举人抵消后一定有所剩余。若不存在持有超过半数选票的选举人则被找出的选票数量一定不超过半数
>
> **由于题意给出必定存在超过半数的元素，所有不必就行计数阶段**
>
> ```c
> int majorityElement(int* nums, int numsSize){
>     int res,k=0;
>     for(int i=0;i<numsSize;i++){
>         if(k==0){
>             res=nums[i];
>             k++;
>         }
>         else{
>             if(nums[i]==res) k++;
>             else k--;
>         }
>     }
>     return res;
> }
> ```
>
> 