> #### [419. 甲板上的战舰](https://leetcode-cn.com/problems/battleships-in-a-board/)
>
> 难度中等79收藏分享切换为英文接收动态反馈
>
> 给定一个二维的甲板， 请计算其中有多少艘战舰。 战舰用 `'X'`表示，空位用 `'.'`表示。 你需要遵守以下规则：
>
> - 给你一个有效的甲板，仅由战舰或者空位组成。
> - 战舰只能水平或者垂直放置。换句话说,战舰只能由 `1xN` (1 行, N 列)组成，或者 `Nx1` (N 行, 1 列)组成，其中N可以是任意大小。
> - 两艘战舰之间至少有一个水平或垂直的空位分隔 - 即没有相邻的战舰。
>
> **示例 :**
>
> ```
> X..X
> ...X
> ...X
> ```
>
> 在上面的甲板中有2艘战舰。
>
> **无效样例 :**
>
> ```
> ...X
> XXXX
> ...X
> ```
>
> 你不会收到这样的无效甲板 - 因为战舰之间至少会有一个空位将它们分开。
>
> **进阶:**
>
> 你可以用**一次扫描算法**，只使用**O(1)额外空间，**并且**不修改**甲板的值来解决这个问题吗？
>
> 通过次数7,411
>
> 提交次数9,875

> 解法一：时间复杂度O(N*M)，空间复杂度O(1)
>
> 题目：*一行或一列可以同时有多个战舰*，一艘战舰的摆放可以是横排或者竖排，连续的X表示一艘战舰，要求每个战舰之间必须要求间隔。当一行或一列中要有多个战舰时每艘战舰之间就必须有间隔。
>
> 原理：逐行扫描计算战舰数，每行找到一个X时，先判断其上是否是X若是则是一辆竖排战舰，不计数。若其上不是X则是一艘为计数战舰，进行计数，并找到该舰舰尾
>
> ```c
> int countBattleships(char** board, int boardSize, int* boardColSize){
>     int count=0,i,j;
> 
>     for(i=0;i<boardSize;i++){
>         for(j=0;j<*boardColSize;j++){
>             if(board[i][j]=='X'){
>                 if(i==0 || board[i-1][j]!='X'){
>                     count++;
>                 }
>                 while(++j<*boardColSize && board[i][j]=='X');// 寻找舰尾，若是连续的X则增加增加循环变量j直到遇到间隔符位置
>             }
>         }
>     }
>     return count;
> }
> 
> 作者：dai-ma-lian-xi-sheng-2
> 链接：https://leetcode-cn.com/problems/battleships-in-a-board/solution/jia-ban-shang-de-po-chuan-by-dai-ma-lian-xi-sheng-/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
> ```
>
> 