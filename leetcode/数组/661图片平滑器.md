> #### [661. 图片平滑器](https://leetcode-cn.com/problems/image-smoother/)
>
> 难度简单66收藏分享切换为英文接收动态反馈
>
> 包含整数的二维矩阵 M 表示一个图片的灰度。你需要设计一个平滑器来让每一个单元的灰度成为平均灰度 (向下舍入) ，平均灰度的计算是周围的8个单元和它本身的值求平均，如果周围的单元格不足八个，则尽可能多的利用它们。
>
> **示例 1:**
>
> ```
> 输入:
> [[1,1,1],
>  [1,0,1],
>  [1,1,1]]
> 输出:
> [[0, 0, 0],
>  [0, 0, 0],
>  [0, 0, 0]]
> 解释:
> 对于点 (0,0), (0,2), (2,0), (2,2): 平均(3/4) = 平均(0.75) = 0
> 对于点 (0,1), (1,0), (1,2), (2,1): 平均(5/6) = 平均(0.83333333) = 0
> 对于点 (1,1): 平均(8/9) = 平均(0.88888889) = 0
> ```
>
> **注意:**
>
> 1. 给定矩阵中的整数范围为 [0, 255]。
> 2. 矩阵的长和宽的范围均为 [1, 150]。
>
> 通过次数11,532
>
> 提交次数21,092

> 解法一：时间复杂度O(MSize\*MColSize)，空间复杂度O(MSize\*MColSize)
>
> 原理：每次循环依次判断周围8个单元是否存在，存在则加入总值进行平均值计算
>
> ```c
> int** imageSmoother(int** M, int MSize, int* MColSize, int* returnSize, int** returnColumnSizes){
>     *returnSize=MSize; 
>     *returnColumnSizes=MColSize;
>     /*
>     ==================================================================================
>     =========================重要区分！！！============================================
>     在为二维指针分配空间时千万不要写成，malloc(sizeof(int))，会导致后续数组首地址无法存放进去，而报错，溢出。
>     int类型和(int*)指针类型的大小是不一样的
>     前者看计算机类型，一般为4Byte（字节），后者是8字节的无符号整型
>     */
>     int **res=(int **)malloc(sizeof(int*)*MSize);
>     for(int i=0;i<MSize;++i){
>         res[i]=(int *)malloc(sizeof(int)*MColSize[i]);
>         for(int j=0;j<MColSize[i];++j){
>             int count=1;
>             int sum=M[i][j];
>             // 左上
>             if(i-1>=0 && j-1>=0){
>                 count++;
>                 sum+=M[i-1][j-1];
>             }
>             // 上
>             if(i-1>=0){
>                 count++;
>                 sum+=M[i-1][j];
>             }
>             // 右上
>             if(i-1>=0 && j+1<MColSize[i-1]){
>                 count++;
>                 sum+=M[i-1][j+1];
>             }
>             // 左
>             if(j-1 >= 0){
>                 count++;
>                 sum+=M[i][j-1];
>             }
>             // 右
>             if(j+1 < MColSize[i]){
>                 count++;
>                 sum+=M[i][j+1];
>             }
>             // 左下
>             if(i+1<MSize && j-1>=0){
>                 count++;
>                 sum+=M[i+1][j-1];
>             }
>             // 下
>             if(i+1<MSize){
>                 count++;
>                 sum+=M[i+1][j];
>             }
>             // 右下
>             if(i+1<MSize && j+1<MColSize[i+1]){
>                 count++;
>                 sum+=M[i+1][j+1];
>             }
>             res[i][j]=(int)sum/count;
>         }
>     }
>     return res;
> }
> ```
>
> 