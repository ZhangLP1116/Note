> #### [73. 矩阵置零](https://leetcode-cn.com/problems/set-matrix-zeroes/)
>
> 难度中等343收藏分享切换为英文接收动态反馈
>
> 给定一个 *m* x *n* 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用**[原地](http://baike.baidu.com/item/原地算法)**算法**。**
>
> **示例 1:**
>
> ```
> 输入: 
> [
>   [1,1,1],
>   [1,0,1],
>   [1,1,1]
> ]
> 输出: 
> [
>   [1,0,1],
>   [0,0,0],
>   [1,0,1]
> ]
> ```
>
> **示例 2:**
>
> ```
> 输入: 
> [
>   [0,1,2,0],
>   [3,4,5,2],
>   [1,3,1,5]
> ]
> 输出: 
> [
>   [0,0,0,0],
>   [0,4,5,0],
>   [0,3,1,0]
> ]
> ```
>
> **进阶:**
>
> - 一个直接的解决方案是使用  O(*m\*n*) 的额外空间，但这并不是一个好的解决方案。
> - 一个简单的改进方案是使用 O(*m* + *n*) 的额外空间，但这仍然不是最好的解决方案。
> - 你能想出一个常数空间的解决方案吗？
>
> 通过次数61,676
>
> 提交次数110,308

> 解法一：标记法
>
> 思路：第一次遍历将所有要被置为0的数标记，第二次遍历根据标记将这些数置零。（不能再第一次循环中直接置零，这样会影响本次循环对0元素的判断）
>
> 标记法1：构建一个n\*m的矩阵第一次遍历的时候将为零的位置或要为零的位置再新矩阵上标记出来，第二次遍历时，根据新矩阵的标记判断是否将该元素置零，*时间复杂度O(N\*M)，空间复杂度O(N\*M)*
>
> 标记法2：根据行和列交点就能确定一个元素坐标的特性，只要创建一个代表列的数组M，代表行的数组N，当有零元素出现时，只要将对应的下标的行列在M、N中标记，即可知道该行和该列会被置为零。*时间复杂度O(N\*M)，空间复杂度O(N+M)*
>
> 标记法3：在标记法2的基础上直接借用矩阵的第0行第0列作为标记数组，来进行标记。*时间复杂度O(N\*M)，空间复杂度O(1)*。在借用行列的情况下需要确定该行列中是否存在0，若存在则要记录，所以使用两个变量取保存0行中或0列中是否有0，若有则在最后将对应的行或列置零。其他非零的元素不用在意，因为若该元素被作为标记则表明该行或列中有0，也会被置零
>
> ```c
> // 标记法3
> void setZeroes(int** matrix, int matrixSize, int* matrixColSize){
>     int n=0,m=0;
>     int flag=0;
>     // 判断0列中是否有0存在，若有则m=1表示0列中存在零
>     for(int i=0;i<matrixSize;i++){
>         if(matrix[i][0]==0){
>             m=1;
>         }
>     }
>     // 判断0行中是否有0存在，若有则n=1表示0行中存在零
>     for(int i=0;i<matrixColSize[0];i++){
>         if(matrix[0][i]==0){
>             n=1;
>         }
>     }
>     // 第一遍遍历做标记，从（1，1）开遍历这矩阵，若存在0，则将对应的行列标记置为0表示改行列有0
>     for(int i=1;i<matrixSize;i++){
>         for(int j=1;j<matrixColSize[0];j++){
>             if(matrix[i][j]==0){
>                 matrix[0][j]=0;
>                 matrix[i][0]=0;
>             }
>         }
>     }
>     // 第二遍遍历，置零操作
>     for(int i=1;i<matrixSize;i++){
>         // 若该行标志为0则，该行全部置零
>         if(matrix[i][0]==0){
>             flag=1;
>         }
>         for(int j=1;j<matrixColSize[0];j++){
>             if(flag){
>                 // 该行全部置零
>                 matrix[i][j]=0;
>             }
>             else{
>                 // 该行没被标志位0，逐列判断列标志是否为0，若是则置零
>                 if(matrix[0][j]==0){
>                     matrix[i][j]=0;
>                 }
>             }
>         }
>         // 重置标志位
>         flag=0;
>     }
>     // 对0列处理，若m=1，表示该列中存在0，则全部置零
>     if(m){
>         for(int i=0;i<matrixSize;i++){
>             matrix[i][0]=0;
>         }
>     }
>     // 对0行处理，若n=1，表示该行中存在0，则全部置零
>     if(n){
>         for(int i=0;i<matrixColSize[0];i++){
>             matrix[0][i]=0;
>         }
>     }
> }
> ```
>
> 