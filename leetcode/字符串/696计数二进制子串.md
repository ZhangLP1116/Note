> #### [696. 计数二进制子串](https://leetcode-cn.com/problems/count-binary-substrings/)
>
> 难度简单341收藏分享切换为英文接收动态反馈
>
> 给定一个字符串 `s`，计算具有相同数量 0 和 1 的非空（连续）子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是连续的。
>
> 重复出现的子串要计算它们出现的次数。
>
>  
>
> **示例 1 :**
>
> ```
> 输入: "00110011"
> 输出: 6
> 解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。
> 
> 请注意，一些重复出现的子串要计算它们出现的次数。
> 
> 另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。
> ```
>
> **示例 2 :**
>
> ```
> 输入: "10101"
> 输出: 4
> 解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。
> ```
>
>  
>
> **提示：**
>
> - `s.length` 在1到50,000之间。
> - `s` 只包含“0”或“1”字符。
>
> 通过次数45,304
>
> 提交次数72,388

> 解法：时间复杂度O（N），空间复杂度O（1）
>
> 题意：找出有多少个数量相同的0，1子串，一个符合条件的字串一定是0，1各占一边如：01，10，0011，1100等。00110011不属于符合条件的字串因为所有的0和1没有连续。
>
> 思路：每次找出一段相同的串和前一段串比较若数量相等则有这个其中符合条件子串的个数为相同串的长度。若前后串长度不相同则符合条件的字串个数为小的串长度。
>
> 如：0011中，前段0长度为2，后端1长度为2，所有符合条件的子串长度为2，0011，01
>
> 如：001中，前段0长度为2，后端1长度为1，所有符合条件的子串长度为1，01
>
> 如：011中，前段0长度为1，后端1长度为2，所有符合条件的子串长度为1，01
>
> ```c
> int countBinarySubstrings(char * s){
>     int left,right,count=0;		// count保存符合提交的子串个数
>     left=find_(s,0);	// left保存前一段串长度
>     if(s[left]=='\0') return 0;
>     for(int i=left;s[i]!='\0';){
>         right=find_(s,i);	// right保存后一段串长度
>         if(left==right){	// 比较left和right长度，取其中较小的数既是符合题意的子串个数
>             count+=left;
>         }
>         else if(left>right){
>             count+=right;
>         }
>         else{
>             count+=left;
>         }
>         i+=right;	// i每次都从上一段末尾开始
>         left=right;	// 每轮循环的后一段都是下一次循环的上一段
>     }
>     return count;
> }
> 
> int find_(char *s,int index){	// 取一段连续相同字符的长度
>     int num=1;
>     char temp=s[index];
>     if(temp=='\0') return 0;
>     for(int i=index+1;s[i]!='\0';i++){
>         if(s[i]==temp) num++;
>         else break;
>     }
>     return num;
> }
> ```
>
> ![image-20210327172706268](image\image-20210327172706268.png)