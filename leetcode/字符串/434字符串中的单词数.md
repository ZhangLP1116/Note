> #### [434. 字符串中的单词数](https://leetcode-cn.com/problems/number-of-segments-in-a-string/)
>
> 难度简单71收藏分享切换为英文接收动态反馈
>
> 统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。
>
> 请注意，你可以假定字符串里不包括任何不可打印的字符。
>
> **示例:**
>
> ```
> 输入: "Hello, my name is John"
> 输出: 5
> 解释: 这里的单词是指连续的不是空格的字符，所以 "Hello," 算作 1 个单词。
> ```
>
> 通过次数27,606
>
> 提交次数74,923

> 解法一：标记控制法，时间复杂度O(n)，空间复杂度O(1)
>
> 根据题意，只有空格不属于单词，并且空格为单词的风格符，所以可以遇到空格就表示一个单词结束，即计数加一。
>
> 陷阱：单纯的遇到空格即增加计数，会出现将连续的空格计数成多个单词，但实际上这些空格可能只算一个单词或者不算单词(整个字符串都是空格)
>
> 解决：增加一个标志位，当遇到不是空格的字符的将标志位*置一*，当遇到空格时判断标志位若标志位为0，则表示之前没有遇到肥空格字母，所以计数不增加；若标志位为1，则表示之前遇到过非空格的字母，则该空格计数，单词加一，并在计数后将标志位*置零*，表示要重新遇到非空格的字母后才能开始计数。
>
> ```c
> int countSegments(char * s){
>     int flag=0;
>     if(strlen(s)==0) return 0;
>     int count=0;
>     for(int i=0;i<strlen(s);i++){
>         // 非空格，将标志为置一
>         if(s[i]!=' '){flag=1;continue;}
>         // 判断标志位，计数后重新将标志为置零
>         else if(flag){
>             flag=0;
>             count++;
>         }
>     }
>     // 结尾判断，若标志位为1则表示最后一个单词没有空格结尾，需要计数
>     if(flag) count++;
>     return count;
> }
> ```
>
> 

