> ## 锁分类
>
> 1. 乐观锁：是一种乐观思想，认为读多写少，读时不加锁，写时加锁
> 2. 悲观锁：是一种悲观思想，认为并发写多，读写时都加锁
> 3. 自旋锁：认为持锁的线程能在短时间内释放资源，等待锁的线程就不会挂起，它们会等一等（自旋）一段时间等待锁释放。
>     自旋是需要消耗CPU的，此时CPU再做无用功。自旋锁可以设置自旋时间避免长时间的不必要等待。
>     自旋锁避免了线程切换的消耗

> ## Synchronized同步锁（悲观锁）
>
> #### 作用范围
>
> 1. synchronized作用于方法时，锁住对象的实例(this)
> 2. synchronized作用于静态方法时，锁住的时Class实例，Class的相关数据存储再永久代中，永久代时全局共享的，所有静态方法锁相当于一个全局锁。
> 3. synchronized作用于一个对象实例时，锁住的是所有以该对象为锁的代码块
>
> #### 核心组件
>
> ![image-20210809100003218](image\image-20210809100003218.png)
>
> ![image-20210809100041679](image\image-20210809100041679.png)
>
> #### 运行机制
>
> ![image-20210809100409212](image\image-20210809100409212.png)

> ## ReentrantLock（乐观锁）
>
> #### 特点
>
> ReentrantLock继承接口Lock并实现其中方法能完成所有synchronized的工作，并且还提供了响应中断锁、可轮询锁请求、定时锁等避免多线程死锁，提供公平锁机制。
>
> #### Lock接口的主要方法
>
> ![image-20210809100911617](image\image-20210809100911617.png)
>
> ![image-20210809100922338](image\image-20210809100922338.png)

> ## 读写锁
>
> ![image-20210809101418084](image\image-20210809101418084.png)

> ## 信号量
>
> ![image-20210809101703404](image\image-20210809101703404.png)

> ## synchronized与ReentrantLock
>
> ![image-20210809154420536](image\image-20210809154420536.png)
>
> ![image-20210809154431947](image\image-20210809154431947.png)

> ![image-20210809102011524](image\image-20210809102011524.png)
>

> ![image-20210809102617184](image\image-20210809102617184.png)

> ![image-20210809102626079](image\image-20210809102626079.png)

> ![image-20210809102851469](image\image-20210809102851469.png)

> ![image-20210809102938391](image\image-20210809102938391.png)

> ![image-20210809103002609](image\image-20210809103002609.png)

> ## 锁优化
>
> ![image-20210809103031503](image\image-20210809103031503.png)